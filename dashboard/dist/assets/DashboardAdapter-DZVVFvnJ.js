var M=Object.defineProperty;var $=(d,t,e)=>t in d?M(d,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[t]=e;var y=(d,t,e)=>$(d,typeof t!="symbol"?t+"":t,e);import{aw as k,i as F,u as q,f as B,t as D,s as I}from"./rpcWorker-BQYX6MpU.js";import{B as O}from"./bamFile-Dg7PF8bJ.js";import{B as H}from"./index-DMgqHXm-.js";import{Q as j}from"./QuickLRU-CBN4ELrQ.js";import{r as U}from"./rxjs-CH3jAc9M.js";import"./crc32-BzEWjjT_.js";import"./AbortablePromiseCache-xs5eyOH3.js";function R(d,t){const s=Object.getOwnPropertyDescriptor(d.prototype,t).get;Object.defineProperty(d.prototype,t,{get(){const a=s.call(this);return Object.defineProperty(this,t,{value:a}),a}})}class P{constructor(t,e,s){this.record=t,this.adapter=e,this.ref=s}id(){return`${this.adapter.id}-${this.record.id}`}get mismatches(){return k(this.record.CIGAR,this.record.tags.MD,this.record.seq,this.ref,this.record.qual)}get qual(){var t;return(t=this.record.qual)==null?void 0:t.join(" ")}get(t){return t==="mismatches"?this.mismatches:t==="qual"?this.qual:this.fields[t]}parent(){}children(){}get fields(){const t=this.record,e=this.adapter,s=t.isPaired();return{start:t.start,name:t.name,end:t.end,score:t.score,strand:t.strand,template_length:t.template_length,flags:t.flags,tags:t.tags,refName:e.refIdToName(t.ref_id),CIGAR:t.CIGAR,seq:t.seq,type:"match",pair_orientation:t.pair_orientation,next_ref:s?e.refIdToName(t.next_refid):void 0,next_pos:s?t.next_pos:void 0,next_segment_position:s?`${e.refIdToName(t.next_refid)}:${t.next_pos+1}`:void 0,uniqueId:this.id()}}toJSON(){return{...this.fields,qual:this.qual}}}R(P,"fields");R(P,"mismatches");class W extends H.BaseFeatureDataAdapter{constructor(){super(...arguments);y(this,"samHeader");y(this,"setupP");y(this,"ultraLongFeatureCache",new j({maxSize:500}));y(this,"configureP")}async configurePre(){const e=this.getConf("bamLocation"),s=this.getConf(["index","location"]),a=this.getConf(["index","indexType"]),i=this.pluginManager,r=a==="CSI",g=new O({bamFilehandle:F.openLocation(e,i),csiFilehandle:r?F.openLocation(s,i):void 0,baiFilehandle:r?void 0:F.openLocation(s,i),yieldThreadTime:Number.POSITIVE_INFINITY}),h=this.getConf("sequenceAdapter");if(h&&this.getSubAdapter){const{dataAdapter:o}=await this.getSubAdapter(h);return{bam:g,sequenceAdapter:o}}else return{bam:g}}async configure(){return this.configureP||(this.configureP=this.configurePre().catch(e=>{throw this.configureP=void 0,e})),this.configureP}async getHeader(e){const{bam:s}=await this.configure();return s.getHeaderText()}async setupPre(e){const{statusCallback:s=()=>{}}=e||{},{bam:a}=await this.configure();return this.samHeader=await q.updateStatus("Downloading index",s,async()=>{const i=await a.getHeader(),r=[],g={};return i==null||i.filter(h=>h.tag==="SQ").forEach((h,o)=>{const c=h.data.find(n=>n.tag==="SN");if(c){const n=c.value;g[n]=o,r[o]=n}}),{idToName:r,nameToId:g}}),this.samHeader}async setup(e){return this.setupP||(this.setupP=this.setupPre(e).catch(s=>{throw this.setupP=void 0,s})),this.setupP}async getRefNames(e){const{idToName:s}=await this.setup(e);return s}async seqFetch(e,s,a){const{sequenceAdapter:i}=await this.configure(),r=i;if(!r||!e)return;const g=r.getFeatures({refName:e,start:s,end:a,assemblyName:""}),h=await B(g.pipe(D()));let o="";if(h.sort((c,n)=>c.get("start")-n.get("start")).forEach(c=>{const n=c.get("start"),m=c.get("end"),p=Math.max(s-n,0),x=Math.min(a-n,m-n)-p,v=c.get("seq")||c.get("residues");o+=v.slice(p,p+x)}),o.length!==a-s)throw new Error(`sequence fetch failed: fetching ${e}:${(s-1).toLocaleString()}-${a.toLocaleString()} returned ${o.length.toLocaleString()} bases, but should have returned ${(a-s).toLocaleString()}`);return o}getFeatures(e,s){const{refName:i,start:r,end:g,originalRefName:h}=e,{stopToken:o,filterBy:c,statusCallback:n=()=>{}}=s||{};return U.ObservableCreate(async m=>{const{bam:p}=await this.configure();await this.setup(s),I.checkStopToken(o);const S=await q.updateStatus("Downloading alignments",n,()=>p.getRecordsForRange(i,r,g));I.checkStopToken(o),await q.updateStatus("Processing alignments",n,async()=>{const{flagInclude:x=0,flagExclude:v=0,tagFilter:l,readName:N,filterReads:A}=c||{},T=Math.ceil(S.length/4e4);for(let b=0;b<S.length;b+=T){if(T>1&&b%T!==0)continue;const u=S[b];let C;u.tags.MD||(C=await this.seqFetch(h||i,u.start,u.end));const E=u.flags;if((E&x)!==x&&!(E&v))continue;if(l&&l.tag){const f=u.tags[l.tag];if(!(l.value==="*"?f!==void 0:`${f}`.split(",").includes(l.value)))continue}const L=l!=null&&l.value&&A[l.value]?A[l.value].map(f=>f.unseenKey):[];if(L.length>0){var w=u.tags.UM?u.tags.UM:"";if(w=w.split(","),!w||!w.some(f=>L.includes(f)))continue}if(N&&u.get("name")!==N)continue;const _=this.ultraLongFeatureCache.get(`${u.id}`);if(_)m.next(_);else{const f=new P(u,this,C);this.ultraLongFeatureCache.set(`${u.id}`,f),m.next(f)}}m.complete()})})}async getMultiRegionFeatureDensityStats(e,s){const{bam:a}=await this.configure();if(a.index){const i=await q.bytesForRegions(e,a),r=this.getConf("fetchSizeLimit");return{bytes:i,fetchSizeLimit:r}}else return super.getMultiRegionFeatureDensityStats(e,s)}freeResources(){}refIdToName(e){var s;return(s=this.samHeader)==null?void 0:s.idToName[e]}}export{W as default};
//# sourceMappingURL=DashboardAdapter-DZVVFvnJ.js.map
