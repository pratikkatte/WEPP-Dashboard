{"version":3,"file":"featureData-XuIg4mRh.js","sources":["../../node_modules/gff-nostream/esm/util.js","../../node_modules/gff-nostream/esm/parse.js","../../node_modules/gff-nostream/esm/api.js","../../node_modules/@jbrowse/plugin-gff3/esm/featureData.js"],"sourcesContent":["// Fast, low-level functions for parsing and formatting GFF3.\n// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n/**\n * Unescape a string value used in a GFF3 attribute.\n *\n * @param stringVal - Escaped GFF3 string value\n * @returns An unescaped string value\n */\nexport function unescape(stringVal) {\n    return stringVal.replaceAll(/%([0-9A-Fa-f]{2})/g, (_match, seq) => String.fromCharCode(parseInt(seq, 16)));\n}\nfunction _escape(regex, s) {\n    return String(s).replace(regex, ch => {\n        const hex = ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0');\n        return `%${hex}`;\n    });\n}\n/**\n * Escape a value for use in a GFF3 attribute value.\n *\n * @param rawVal - Raw GFF3 attribute value\n * @returns An escaped string value\n */\nexport function escape(rawVal) {\n    return _escape(/[\\n;\\r\\t=%&,\\u0000-\\u001f\\u007f-\\u00ff]/g, rawVal);\n}\n/**\n * Escape a value for use in a GFF3 column value.\n *\n * @param rawVal - Raw GFF3 column value\n * @returns An escaped column value\n */\nexport function escapeColumn(rawVal) {\n    return _escape(/[\\n\\r\\t%\\u0000-\\u001f\\u007f-\\u00ff]/g, rawVal);\n}\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributes(attrString) {\n    if (!attrString.length || attrString === '.') {\n        return {};\n    }\n    const attrs = {};\n    attrString\n        .replace(/\\r?\\n$/, '')\n        .split(';')\n        .forEach(a => {\n        var _a;\n        const nv = a.split('=', 2);\n        if (!((_a = nv[1]) === null || _a === void 0 ? void 0 : _a.length)) {\n            return;\n        }\n        nv[0] = nv[0].trim();\n        let arec = attrs[nv[0].trim()];\n        if (!arec) {\n            arec = [];\n            attrs[nv[0]] = arec;\n        }\n        arec.push(...nv[1]\n            .split(',')\n            .map(s => s.trim())\n            .map(unescape));\n    });\n    return attrs;\n}\n/**\n * Parse a GFF3 feature line\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeature(line) {\n    // split the line into columns and replace '.' with null in each column\n    const f = line.split('\\t').map(a => (a === '.' || a === '' ? null : a));\n    // unescape only the ref, source, and type columns\n    const parsed = {\n        seq_id: f[0] && unescape(f[0]),\n        source: f[1] && unescape(f[1]),\n        type: f[2] && unescape(f[2]),\n        start: f[3] === null ? null : parseInt(f[3], 10),\n        end: f[4] === null ? null : parseInt(f[4], 10),\n        score: f[5] === null ? null : parseFloat(f[5]),\n        strand: f[6],\n        phase: f[7],\n        attributes: f[8] === null ? null : parseAttributes(f[8]),\n    };\n    return parsed;\n}\n/**\n * Parse a GFF3 directive line.\n *\n * @param line - GFF3 directive line\n * @returns The parsed directive\n */\nexport function parseDirective(line) {\n    var _a, _b;\n    const match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line);\n    if (!match) {\n        return null;\n    }\n    const [, name] = match;\n    let [, , contents] = match;\n    const parsed = { directive: name };\n    if (contents.length) {\n        contents = contents.replace(/\\r?\\n$/, '');\n        parsed.value = contents;\n    }\n    // do a little additional parsing for sequence-region and genome-build directives\n    if (name === 'sequence-region') {\n        const c = contents.split(/\\s+/, 3);\n        return {\n            ...parsed,\n            seq_id: c[0],\n            start: (_a = c[1]) === null || _a === void 0 ? void 0 : _a.replaceAll(/\\D/g, ''),\n            end: (_b = c[2]) === null || _b === void 0 ? void 0 : _b.replaceAll(/\\D/g, ''),\n        };\n    }\n    else if (name === 'genome-build') {\n        const [source, buildName] = contents.split(/\\s+/, 2);\n        return {\n            ...parsed,\n            source,\n            buildName,\n        };\n    }\n    return parsed;\n}\n/**\n * Format an attributes object into a string suitable for the 9th column of GFF3.\n *\n * @param attrs - Attributes\n * @returns GFF3 9th column string\n */\nexport function formatAttributes(attrs) {\n    const attrOrder = [];\n    Object.entries(attrs).forEach(([tag, val]) => {\n        if (!val) {\n            return;\n        }\n        let valstring;\n        if (val.hasOwnProperty('toString')) {\n            valstring = escape(val.toString());\n            // } else if (Array.isArray(val.values)) {\n            //   valstring = val.values.map(escape).join(',')\n        }\n        else if (Array.isArray(val)) {\n            valstring = val.map(escape).join(',');\n        }\n        else {\n            valstring = escape(val);\n        }\n        attrOrder.push(`${escape(tag)}=${valstring}`);\n    });\n    return attrOrder.length ? attrOrder.join(';') : '.';\n}\nfunction _formatSingleFeature(f, seenFeature) {\n    const attrString = f.attributes === null || f.attributes === undefined\n        ? '.'\n        : formatAttributes(f.attributes);\n    const fields = [\n        f.seq_id === null ? '.' : escapeColumn(f.seq_id),\n        f.source === null ? '.' : escapeColumn(f.source),\n        f.type === null ? '.' : escapeColumn(f.type),\n        f.start === null ? '.' : escapeColumn(f.start),\n        f.end === null ? '.' : escapeColumn(f.end),\n        f.score === null ? '.' : escapeColumn(f.score),\n        f.strand === null ? '.' : escapeColumn(f.strand),\n        f.phase === null ? '.' : escapeColumn(f.phase),\n        attrString,\n    ];\n    const formattedString = `${fields.join('\\t')}\\n`;\n    // if we have already output this exact feature, skip it\n    if (seenFeature[formattedString]) {\n        return '';\n    }\n    seenFeature[formattedString] = true;\n    return formattedString;\n}\nfunction _formatFeature(feature, seenFeature) {\n    if (Array.isArray(feature)) {\n        return feature.map(f => _formatFeature(f, seenFeature)).join('');\n    }\n    const strings = [_formatSingleFeature(feature, seenFeature)];\n    if (_isFeatureLineWithRefs(feature)) {\n        strings.push(...feature.child_features.map(f => _formatFeature(f, seenFeature)), ...feature.derived_features.map(f => _formatFeature(f, seenFeature)));\n    }\n    return strings.join('');\n}\n/**\n * Format a feature object or array of feature objects into one or more lines of\n * GFF3.\n *\n * @param featureOrFeatures - A feature object or array of feature objects\n * @returns A string of one or more GFF3 lines\n */\nexport function formatFeature(featureOrFeatures) {\n    const seen = {};\n    return _formatFeature(featureOrFeatures, seen);\n}\n/**\n * Format a directive into a line of GFF3.\n *\n * @param directive - A directive object\n * @returns A directive line string\n */\nexport function formatDirective(directive) {\n    let str = `##${directive.directive}`;\n    if (directive.value) {\n        str += ` ${directive.value}`;\n    }\n    str += '\\n';\n    return str;\n}\n/**\n * Format a comment into a GFF3 comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param comment - A comment object\n * @returns A comment line string\n */\nexport function formatComment(comment) {\n    return `# ${comment.comment}\\n`;\n}\n/**\n * Format a sequence object as FASTA\n *\n * @param seq - A sequence object\n * @returns Formatted single FASTA sequence string\n */\nexport function formatSequence(seq) {\n    return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\\n${seq.sequence}\\n`;\n}\n/**\n * Format a directive, comment, sequence, or feature, or array of such items,\n * into one or more lines of GFF3.\n *\n * @param itemOrItems - A comment, sequence, or feature, or array of such items\n * @returns A formatted string or array of strings\n */\nexport function formatItem(itemOrItems) {\n    function formatSingleItem(item) {\n        if ('attributes' in item) {\n            return formatFeature(item);\n        }\n        if ('directive' in item) {\n            return formatDirective(item);\n        }\n        if ('sequence' in item) {\n            return formatSequence(item);\n        }\n        if ('comment' in item) {\n            return formatComment(item);\n        }\n        return '# (invalid item found during format)\\n';\n    }\n    if (Array.isArray(itemOrItems)) {\n        return itemOrItems.map(formatSingleItem);\n    }\n    return formatSingleItem(itemOrItems);\n}\nfunction _isFeatureLineWithRefs(featureLine) {\n    return (featureLine.child_features !== undefined &&\n        featureLine.derived_features !== undefined);\n}\n//# sourceMappingURL=util.js.map","import * as GFF3 from './util';\nconst containerAttributes = {\n    Parent: 'child_features',\n    Derives_from: 'derived_features',\n};\nexport class FASTAParser {\n    constructor(seqCallback) {\n        this.seqCallback = seqCallback;\n        this.currentSequence = undefined;\n    }\n    addLine(line) {\n        const defMatch = /^>\\s*(\\S+)\\s*(.*)/.exec(line);\n        if (defMatch) {\n            this._flush();\n            this.currentSequence = { id: defMatch[1], sequence: '' };\n            if (defMatch[2]) {\n                this.currentSequence.description = defMatch[2].trim();\n            }\n        }\n        else if (this.currentSequence && /\\S/.test(line)) {\n            this.currentSequence.sequence += line.replaceAll(/\\s/g, '');\n        }\n    }\n    _flush() {\n        if (this.currentSequence) {\n            this.seqCallback(this.currentSequence);\n        }\n    }\n    finish() {\n        this._flush();\n    }\n}\nexport default class Parser {\n    constructor(args) {\n        this.fastaParser = undefined;\n        // if this is true, the parser ignores the\n        // rest of the lines in the file.  currently\n        // set when the file switches over to FASTA\n        this.eof = false;\n        this.lineNumber = 0;\n        // features that we have to keep on hand for now because they\n        // might be referenced by something else\n        this._underConstructionTopLevel = [];\n        // index of the above by ID\n        this._underConstructionById = {};\n        this._completedReferences = {};\n        // features that reference something we have not seen yet\n        // structured as:\n        // {  'some_id' : {\n        //     'Parent' : [ orphans that have a Parent attr referencing it ],\n        //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n        //    }\n        // }\n        this._underConstructionOrphans = {};\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        const nullFunc = () => { };\n        this.featureCallback = args.featureCallback || nullFunc;\n        this.endCallback = args.endCallback || nullFunc;\n        this.commentCallback = args.commentCallback || nullFunc;\n        this.errorCallback = args.errorCallback || nullFunc;\n        this.directiveCallback = args.directiveCallback || nullFunc;\n        this.sequenceCallback = args.sequenceCallback || nullFunc;\n        this.disableDerivesFromReferences =\n            args.disableDerivesFromReferences || false;\n        // number of lines to buffer\n        this.bufferSize = args.bufferSize === undefined ? 1000 : args.bufferSize;\n    }\n    addLine(line) {\n        // if we have transitioned to a fasta section, just delegate to that parser\n        if (this.fastaParser) {\n            this.fastaParser.addLine(line);\n            return;\n        }\n        if (this.eof) {\n            // otherwise, if we are done, ignore this line\n            return;\n        }\n        this.lineNumber += 1;\n        if (/^\\s*[^#\\s>]/.test(line)) {\n            // feature line, most common case\n            this._bufferLine(line);\n            return;\n        }\n        const match = /^\\s*(#+)(.*)/.exec(line);\n        if (match) {\n            // directive or comment\n            const [, hashsigns] = match;\n            let [, , contents] = match;\n            if (hashsigns.length === 3) {\n                // sync directive, all forward-references are resolved.\n                this._emitAllUnderConstructionFeatures();\n            }\n            else if (hashsigns.length === 2) {\n                const directive = GFF3.parseDirective(line);\n                if (directive) {\n                    if (directive.directive === 'FASTA') {\n                        this._emitAllUnderConstructionFeatures();\n                        this.eof = true;\n                        this.fastaParser = new FASTAParser(this.sequenceCallback);\n                    }\n                    else {\n                        this._emitItem(directive);\n                    }\n                }\n            }\n            else {\n                contents = contents.replace(/\\s*/, '');\n                this._emitItem({ comment: contents });\n            }\n        }\n        else if (/^\\s*$/.test(line)) {\n            // blank line, do nothing\n        }\n        else if (/^\\s*>/.test(line)) {\n            // implicit beginning of a FASTA section\n            this._emitAllUnderConstructionFeatures();\n            this.eof = true;\n            this.fastaParser = new FASTAParser(this.sequenceCallback);\n            this.fastaParser.addLine(line);\n        }\n        else {\n            // it's a parse error\n            const errLine = line.replaceAll(/\\r?\\n?$/g, '');\n            throw new Error(`GFF3 parse error.  Cannot parse '${errLine}'.`);\n        }\n    }\n    finish() {\n        this._emitAllUnderConstructionFeatures();\n        if (this.fastaParser) {\n            this.fastaParser.finish();\n        }\n        this.endCallback();\n    }\n    _emitItem(i) {\n        if (Array.isArray(i)) {\n            this.featureCallback(i);\n        }\n        else if ('directive' in i) {\n            this.directiveCallback(i);\n        }\n        else if ('comment' in i) {\n            this.commentCallback(i);\n        }\n    }\n    _enforceBufferSizeLimit(additionalItemCount = 0) {\n        const _unbufferItem = (item) => {\n            var _a, _b;\n            if (item && Array.isArray(item) && ((_b = (_a = item[0].attributes) === null || _a === void 0 ? void 0 : _a.ID) === null || _b === void 0 ? void 0 : _b[0])) {\n                const ids = item[0].attributes.ID;\n                ids.forEach(id => {\n                    delete this._underConstructionById[id];\n                    delete this._completedReferences[id];\n                });\n                item.forEach(i => {\n                    if (i.child_features) {\n                        i.child_features.forEach(c => _unbufferItem(c));\n                    }\n                    if (i.derived_features) {\n                        i.derived_features.forEach(d => _unbufferItem(d));\n                    }\n                });\n            }\n        };\n        while (this._underConstructionTopLevel.length + additionalItemCount >\n            this.bufferSize) {\n            const item = this._underConstructionTopLevel.shift();\n            if (item) {\n                this._emitItem(item);\n                _unbufferItem(item);\n            }\n        }\n    }\n    /**\n     * return all under-construction features, called when we know\n     * there will be no additional data to attach to them\n     */\n    _emitAllUnderConstructionFeatures() {\n        this._underConstructionTopLevel.forEach(this._emitItem.bind(this));\n        this._underConstructionTopLevel = [];\n        this._underConstructionById = {};\n        this._completedReferences = {};\n        // if we have any orphans hanging around still, this is a\n        // problem. die with a parse error\n        if (Array.from(Object.values(this._underConstructionOrphans)).length) {\n            throw new Error(`some features reference other features that do not exist in the file (or in the same '###' scope). ${Object.keys(this._underConstructionOrphans).join(',')}`);\n        }\n    }\n    // do the right thing with a newly-parsed feature line\n    _bufferLine(line) {\n        var _a, _b, _c;\n        const rawFeatureLine = GFF3.parseFeature(line);\n        const featureLine = {\n            ...rawFeatureLine,\n            child_features: [],\n            derived_features: [],\n        };\n        // featureLine._lineNumber = this.lineNumber //< debugging aid\n        // NOTE: a feature is an arrayref of one or more feature lines.\n        const ids = ((_a = featureLine.attributes) === null || _a === void 0 ? void 0 : _a.ID) || [];\n        const parents = ((_b = featureLine.attributes) === null || _b === void 0 ? void 0 : _b.Parent) || [];\n        const derives = this.disableDerivesFromReferences\n            ? []\n            : ((_c = featureLine.attributes) === null || _c === void 0 ? void 0 : _c.Derives_from) || [];\n        if (!ids.length && !parents.length && !derives.length) {\n            // if it has no IDs and does not refer to anything, we can just\n            // output it\n            this._emitItem([featureLine]);\n            return;\n        }\n        let feature = undefined;\n        ids.forEach(id => {\n            const existing = this._underConstructionById[id];\n            if (existing) {\n                // another location of the same feature\n                if (existing[existing.length - 1].type !== featureLine.type) {\n                    this._parseError(`multi-line feature \"${id}\" has inconsistent types: \"${featureLine.type}\", \"${existing[existing.length - 1].type}\"`);\n                }\n                existing.push(featureLine);\n                feature = existing;\n            }\n            else {\n                // haven't seen it yet, so buffer it so we can attach\n                // child features to it\n                feature = [featureLine];\n                this._enforceBufferSizeLimit(1);\n                if (!parents.length && !derives.length) {\n                    this._underConstructionTopLevel.push(feature);\n                }\n                this._underConstructionById[id] = feature;\n                // see if we have anything buffered that refers to it\n                this._resolveReferencesTo(feature, id);\n            }\n        });\n        // try to resolve all its references\n        this._resolveReferencesFrom(feature || [featureLine], { Parent: parents, Derives_from: derives }, ids);\n    }\n    _resolveReferencesTo(feature, id) {\n        const references = this._underConstructionOrphans[id];\n        //   references is of the form\n        //   {\n        //     'Parent' : [ orphans that have a Parent attr referencing this feature ],\n        //     'Derives_from' : [ orphans that have a Derives_from attr referencing this feature ],\n        //    }\n        if (!references) {\n            return;\n        }\n        feature.forEach(loc => {\n            loc.child_features.push(...references.Parent);\n        });\n        feature.forEach(loc => {\n            loc.derived_features.push(...references.Derives_from);\n        });\n        delete this._underConstructionOrphans[id];\n    }\n    _parseError(message) {\n        this.eof = true;\n        this.errorCallback(`${this.lineNumber}: ${message}`);\n    }\n    _resolveReferencesFrom(feature, references, ids) {\n        // this is all a bit more awkward in javascript than it was in perl\n        function postSet(obj, slot1, slot2) {\n            let subObj = obj[slot1];\n            if (!subObj) {\n                subObj = {};\n                obj[slot1] = subObj;\n            }\n            const returnVal = subObj[slot2] || false;\n            subObj[slot2] = true;\n            return returnVal;\n        }\n        references.Parent.forEach(toId => {\n            const otherFeature = this._underConstructionById[toId];\n            if (otherFeature) {\n                const pname = containerAttributes.Parent;\n                if (!ids.filter(id => postSet(this._completedReferences, id, `Parent,${toId}`)).length) {\n                    otherFeature.forEach(location => {\n                        location[pname].push(feature);\n                    });\n                }\n            }\n            else {\n                let ref = this._underConstructionOrphans[toId];\n                if (!ref) {\n                    ref = {\n                        Parent: [],\n                        Derives_from: [],\n                    };\n                    this._underConstructionOrphans[toId] = ref;\n                }\n                ref.Parent.push(feature);\n            }\n        });\n        references.Derives_from.forEach(toId => {\n            const otherFeature = this._underConstructionById[toId];\n            if (otherFeature) {\n                const pname = containerAttributes.Derives_from;\n                if (!ids.filter(id => postSet(this._completedReferences, id, `Derives_from,${toId}`)).length) {\n                    otherFeature.forEach(location => {\n                        location[pname].push(feature);\n                    });\n                }\n            }\n            else {\n                let ref = this._underConstructionOrphans[toId];\n                if (!ref) {\n                    ref = {\n                        Parent: [],\n                        Derives_from: [],\n                    };\n                    this._underConstructionOrphans[toId] = ref;\n                }\n                ref.Derives_from.push(feature);\n            }\n        });\n    }\n}\n//# sourceMappingURL=parse.js.map","import Parser from './parse';\n/**\n * Synchronously parse a string containing GFF3 and return an array of the\n * parsed items.\n *\n * @param str - GFF3 string\n * @param inputOptions - Parsing options\n * @returns array of parsed features, directives, comments and/or sequences\n */\nexport function parseStringSync(str) {\n    const items = [];\n    const parser = new Parser({\n        featureCallback: arg => items.push(arg),\n        disableDerivesFromReferences: true,\n        errorCallback: err => {\n            throw err;\n        },\n    });\n    for (const line of str.split(/\\r?\\n/)) {\n        parser.addLine(line);\n    }\n    parser.finish();\n    return items;\n}\n//# sourceMappingURL=api.js.map","export function featureData(data) {\n    const { end, start, child_features, derived_features, attributes, type, source, phase, seq_id, score, strand, } = data;\n    let strand2;\n    if (strand === '+') {\n        strand2 = 1;\n    }\n    else if (strand === '-') {\n        strand2 = -1;\n    }\n    else if (strand === '.') {\n        strand2 = 0;\n    }\n    const defaultFields = new Set([\n        'start',\n        'end',\n        'seq_id',\n        'score',\n        'type',\n        'source',\n        'phase',\n        'strand',\n    ]);\n    const dataAttributes = attributes || {};\n    const resultAttributes = {};\n    for (const a of Object.keys(dataAttributes)) {\n        let b = a.toLowerCase();\n        if (defaultFields.has(b)) {\n            b += '2';\n        }\n        if (dataAttributes[a] && a !== '_lineHash') {\n            let attr = dataAttributes[a];\n            if (Array.isArray(attr) && attr.length === 1) {\n                ;\n                [attr] = attr;\n            }\n            resultAttributes[b] = attr;\n        }\n    }\n    return {\n        ...resultAttributes,\n        start: start - 1,\n        end: end,\n        strand: strand2,\n        type,\n        source,\n        refName: seq_id,\n        derived_features,\n        phase: phase === null ? undefined : Number(phase),\n        score: score === null ? undefined : score,\n        subfeatures: child_features.flatMap(childLocs => childLocs.map(childLoc => featureData(childLoc))),\n    };\n}\n"],"names":["unescape","stringVal","_match","seq","parseAttributes","attrString","attrs","a","_a","nv","arec","s","parseFeature","line","f","parseDirective","_b","match","name","contents","parsed","c","source","buildName","containerAttributes","FASTAParser","seqCallback","defMatch","Parser","args","nullFunc","hashsigns","directive","GFF3.parseDirective","errLine","i","additionalItemCount","_unbufferItem","item","id","d","_c","featureLine","GFF3.parseFeature","ids","parents","derives","feature","existing","references","loc","message","postSet","obj","slot1","slot2","subObj","returnVal","toId","otherFeature","pname","location","ref","parseStringSync","str","items","parser","arg","err","featureData","data","end","start","child_features","derived_features","attributes","type","phase","seq_id","score","strand","strand2","defaultFields","dataAttributes","resultAttributes","b","attr","childLocs","childLoc"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}