{"version":3,"file":"AbortablePromiseCache-xs5eyOH3.js","sources":["../node_modules/@gmod/abortable-promise-cache/esm/AggregateAbortController.js","../node_modules/@gmod/abortable-promise-cache/esm/AggregateStatusReporter.js","../node_modules/@gmod/abortable-promise-cache/esm/AbortablePromiseCache.js"],"sourcesContent":["class NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\n//# sourceMappingURL=AggregateAbortController.js.map","export default class AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        for (const elt of this.callbacks) {\n            elt(message);\n        }\n    }\n}\n//# sourceMappingURL=AggregateStatusReporter.js.map","import AggregateAbortController from './AggregateAbortController';\nimport AggregateStatusReporter from './AggregateStatusReporter';\nexport default class AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController();\n        const statusReporter = new AggregateStatusReporter();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(error => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(error);\n            throw error;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\n//# sourceMappingURL=AbortablePromiseCache.js.map"],"names":["NullSignal","AggregateAbortController","signal","AggregateStatusReporter","callback","message","elt","AbortablePromiseCache","fill","cache","exception","key","entry","data","statusCallback","aborter","statusReporter","newEntry","error","promise","checkForSingleAbort","result","cacheEntry","cachedEntry","keyIter","deleteCount"],"mappings":"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","x_google_ignoreList":[0,1,2]}