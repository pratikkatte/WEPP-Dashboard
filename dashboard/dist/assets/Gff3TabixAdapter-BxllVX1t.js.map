{"version":3,"file":"Gff3TabixAdapter-BxllVX1t.js","sources":["../../node_modules/@jbrowse/plugin-gff3/esm/Gff3TabixAdapter/Gff3TabixAdapter.js"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix';\nimport { readConfObject } from '@jbrowse/core/configuration';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { doesIntersect2 } from '@jbrowse/core/util/range';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { parseStringSync } from 'gff-nostream';\nimport { featureData } from '../featureData';\nexport default class Gff3TabixAdapter extends BaseFeatureDataAdapter {\n    constructor(config, getSubAdapter, pluginManager) {\n        super(config, getSubAdapter, pluginManager);\n        const gffGzLocation = readConfObject(config, 'gffGzLocation');\n        const indexType = readConfObject(config, ['index', 'indexType']);\n        const location = readConfObject(config, ['index', 'location']);\n        const dontRedispatch = readConfObject(config, 'dontRedispatch');\n        this.dontRedispatch = dontRedispatch || ['chromosome', 'contig', 'region'];\n        this.gff = new TabixIndexedFile({\n            filehandle: openLocation(gffGzLocation, this.pluginManager),\n            csiFilehandle: indexType === 'CSI'\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            tbiFilehandle: indexType !== 'CSI'\n                ? openLocation(location, this.pluginManager)\n                : undefined,\n            chunkCacheSize: 50 * 2 ** 20,\n            renameRefSeqs: (n) => n,\n        });\n    }\n    async getRefNames(opts = {}) {\n        return this.gff.getReferenceSequenceNames(opts);\n    }\n    async getHeader() {\n        return this.gff.getHeader();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const metadata = await this.gff.getMetadata();\n            await this.getFeaturesHelper(query, opts, metadata, observer, true);\n        }, opts.stopToken);\n    }\n    async getFeaturesHelper(query, opts, metadata, observer, allowRedispatch, originalQuery = query) {\n        var _a, _b;\n        try {\n            const lines = [];\n            await this.gff.getLines(query.refName, query.start, query.end, (line, fileOffset) => {\n                lines.push(this.parseLine(metadata.columnNumbers, line, fileOffset));\n            });\n            if (allowRedispatch && lines.length) {\n                let minStart = Number.POSITIVE_INFINITY;\n                let maxEnd = Number.NEGATIVE_INFINITY;\n                for (const line of lines) {\n                    const featureType = line.fields[2];\n                    if (!this.dontRedispatch.includes(featureType)) {\n                        const start = line.start - 1;\n                        if (start < minStart) {\n                            minStart = start;\n                        }\n                        if (line.end > maxEnd) {\n                            maxEnd = line.end;\n                        }\n                    }\n                }\n                if (maxEnd > query.end || minStart < query.start) {\n                    await this.getFeaturesHelper({ ...query, start: minStart, end: maxEnd }, opts, metadata, observer, false, query);\n                    return;\n                }\n            }\n            const gff3 = lines\n                .map(lineRecord => {\n                if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n                    if (!lineRecord.fields[8].includes('_lineHash')) {\n                        lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`;\n                    }\n                }\n                else {\n                    lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`;\n                }\n                return lineRecord.fields.join('\\t');\n            })\n                .join('\\n');\n            for (const featureLocs of parseStringSync(gff3)) {\n                for (const featureLoc of featureLocs) {\n                    const f = new SimpleFeature({\n                        data: featureData(featureLoc),\n                        id: `${this.id}-offset-${(_b = (_a = featureLoc.attributes) === null || _a === void 0 ? void 0 : _a._lineHash) === null || _b === void 0 ? void 0 : _b[0]}`,\n                    });\n                    if (doesIntersect2(f.get('start'), f.get('end'), originalQuery.start, originalQuery.end)) {\n                        observer.next(f);\n                    }\n                }\n            }\n            observer.complete();\n        }\n        catch (e) {\n            observer.error(e);\n        }\n    }\n    parseLine(columnNumbers, line, fileOffset) {\n        const fields = line.split('\\t');\n        return {\n            start: +fields[columnNumbers.start - 1],\n            end: +fields[columnNumbers.end - 1],\n            lineHash: fileOffset,\n            fields,\n        };\n    }\n    freeResources() { }\n}\n"],"names":["Gff3TabixAdapter","BaseFeatureDataAdapter","config","getSubAdapter","pluginManager","gffGzLocation","readConfObject","indexType","location","dontRedispatch","TabixIndexedFile","openLocation","n","opts","query","ObservableCreate","observer","metadata","allowRedispatch","originalQuery","_a","_b","lines","line","fileOffset","minStart","maxEnd","featureType","start","gff3","lineRecord","featureLocs","parseStringSync","featureLoc","f","SimpleFeature","featureData","doesIntersect2","e","columnNumbers","fields"],"mappings":"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","x_google_ignoreList":[0]}