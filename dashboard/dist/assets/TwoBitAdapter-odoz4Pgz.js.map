{"version":3,"file":"TwoBitAdapter-odoz4Pgz.js","sources":["../../node_modules/@gmod/twobit/esm/bigint-polyfill/pure.js","../../node_modules/@gmod/twobit/esm/bigint-polyfill/polyfill.js","../../node_modules/@gmod/twobit/esm/twoBitFile.js","../../node_modules/@jbrowse/plugin-sequence/esm/TwoBitAdapter/TwoBitAdapter.js"],"sourcesContent":["const BigInt32 = BigInt(32);\nexport function getBigInt64(dataView, byteOffset, littleEndian) {\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    return ((BigInt(dataView.getInt32(byteOffset, littleEndian) * bigEndianMask +\n        dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask) <<\n        BigInt32) |\n        BigInt(dataView.getUint32(byteOffset, littleEndian) * littleEndianMask +\n            dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask));\n}\nexport function getBigUint64(dataView, byteOffset, littleEndian) {\n    const a = dataView.getUint32(byteOffset, littleEndian);\n    const b = dataView.getUint32(byteOffset + 4, littleEndian);\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    // This branch-less optimization is 77x faster than normal ternary operator.\n    // and only 3% slower than native implementation\n    // https://jsbench.me/p8kyhg1eqv/1\n    return ((BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32) |\n        BigInt(a * littleEndianMask + b * bigEndianMask));\n}\n//# sourceMappingURL=pure.js.map","import { getBigInt64, getBigUint64 } from './pure';\nif (!('getBigInt64' in DataView)) {\n    DataView.prototype.getBigInt64 = function (byteOffset, littleEndian) {\n        return getBigInt64(this, byteOffset, littleEndian);\n    };\n}\nif (!('getBigUint64' in DataView)) {\n    DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n        return getBigUint64(this, byteOffset, littleEndian);\n    };\n}\n//# sourceMappingURL=polyfill.js.map","import { LocalFile } from 'generic-filehandle';\nimport { Buffer } from 'buffer';\nconst TWOBIT_MAGIC = 0x1a412743;\nconst twoBit = ['T', 'C', 'A', 'G'];\n// byteTo4Bases is an array of byteValue -> 'ACTG'\nconst byteTo4Bases = [];\nfor (let index = 0; index < 256; index++) {\n    byteTo4Bases.push(twoBit[(index >> 6) & 3] +\n        twoBit[(index >> 4) & 3] +\n        twoBit[(index >> 2) & 3] +\n        twoBit[index & 3]);\n}\nconst maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase());\nexport default class TwoBitFile {\n    /**\n     * @param {object} args\n     * @param {string} [args.path] filesystem path for the .2bit file to open\n     * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n     *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n     */\n    constructor({ filehandle, path, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else {\n            throw new Error('must supply path or filehandle');\n        }\n    }\n    async _detectEndianness() {\n        const returnValue = await this.filehandle.read(Buffer.allocUnsafe(8), 0, 8, 0);\n        const { buffer } = returnValue;\n        if (buffer.readInt32LE(0) === TWOBIT_MAGIC) {\n            this.version = buffer.readInt32LE(4);\n        }\n        else if (buffer.readInt32BE(0) === TWOBIT_MAGIC) {\n            throw new Error('big endian not supported');\n        }\n        else {\n            throw new Error('not a 2bit file');\n        }\n    }\n    getHeader() {\n        if (!this.headerP) {\n            this.headerP = this._getHeader().catch((error) => {\n                this.headerP = undefined;\n                throw error;\n            });\n        }\n        return this.headerP;\n    }\n    async _getHeader() {\n        await this._detectEndianness();\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(16), 0, 16, 0);\n        const b = buffer;\n        const le = true;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        const magic = dataView.getInt32(offset, le);\n        offset += 4;\n        if (magic !== 0x1a412743) {\n            throw new Error(`Wrong magic number ${magic}`);\n        }\n        const version = dataView.getInt32(offset, le);\n        offset += 4;\n        const sequenceCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const reserved = dataView.getUint32(offset, le);\n        return {\n            version,\n            magic,\n            sequenceCount,\n            reserved,\n        };\n    }\n    getIndex() {\n        if (!this.indexP) {\n            this.indexP = this._getIndex().catch((error) => {\n                this.indexP = undefined;\n                throw error;\n            });\n        }\n        return this.indexP;\n    }\n    async _getIndex() {\n        const header = await this.getHeader();\n        const maxIndexLength = 8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(maxIndexLength), 0, maxIndexLength, 8);\n        const le = true;\n        const b = buffer;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        const sequenceCount = dataView.getUint32(offset, le);\n        offset += 4;\n        // const reserved = dataView.getUint32(offset, le)\n        offset += 4;\n        const indexData = [];\n        for (let i = 0; i < sequenceCount; i++) {\n            const nameLength = dataView.getUint8(offset);\n            offset += 1;\n            const name = buffer\n                .subarray(offset, offset + nameLength)\n                .toString();\n            offset += nameLength;\n            if (header.version === 1) {\n                const dataOffset = Number(dataView.getBigUint64(offset, le));\n                offset += 8;\n                indexData.push({ offset: dataOffset, name });\n            }\n            else {\n                const dataOffset = dataView.getUint32(offset, le);\n                offset += 4;\n                indexData.push({ offset: dataOffset, name });\n            }\n        }\n        return Object.fromEntries(indexData.map(({ name, offset }) => [name, offset]));\n    }\n    /**\n     * @returns {Promise} for an array of string sequence names that are found in the file\n     */\n    async getSequenceNames() {\n        const index = await this.getIndex();\n        return Object.keys(index);\n    }\n    /**\n     * @returns {Promise} for an object listing the lengths of all sequences like\n     * `{seqName: length, ...}`.\n     *\n     * note: this is a relatively slow operation especially if there are many\n     * refseqs in the file, if you can get this information from a different file\n     * e.g. a chrom.sizes file, it will be much faster\n     */\n    async getSequenceSizes() {\n        const index = await this.getIndex();\n        const seqNames = Object.keys(index);\n        const sizePromises = Object.values(index).map(offset => this._getSequenceSize(offset));\n        const sizes = await Promise.all(sizePromises);\n        const returnObject = {};\n        for (const [index_, seqName] of seqNames.entries()) {\n            returnObject[seqName] = sizes[index_];\n        }\n        return returnObject;\n    }\n    /**\n     * @param {string} seqName name of the sequence\n     * @returns {Promise} for the sequence's length, or undefined if it is not in the file\n     */\n    async getSequenceSize(seqName) {\n        const index = await this.getIndex();\n        const offset = index[seqName];\n        if (!offset) {\n            return undefined;\n        }\n        return this._getSequenceSize(offset);\n    }\n    async _getSequenceSize(offset) {\n        return this._record1(offset).then(f => f.dnaSize);\n    }\n    async _record1(offset2, len = 8) {\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(len), 0, len, offset2);\n        const b = buffer;\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const dnaSize = dataView.getUint32(offset, le);\n        offset += 4;\n        const nBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        return { dnaSize, nBlockCount };\n    }\n    async _record2(offset2, len) {\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(len), 0, len, offset2);\n        const b = buffer;\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const nBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const nBlockStarts = [];\n        for (let i = 0; i < nBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            nBlockStarts.push(elt);\n        }\n        const nBlockSizes = [];\n        for (let i = 0; i < nBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            nBlockSizes.push(elt);\n        }\n        const maskBlockCount = dataView.getUint32(offset, le);\n        return {\n            maskBlockCount,\n            nBlockSizes,\n            nBlockStarts,\n        };\n    }\n    async _record3(offset2, len) {\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(len), 0, len, offset2);\n        const b = buffer;\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const maskBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const maskBlockStarts = [];\n        for (let i = 0; i < maskBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            maskBlockStarts.push(elt);\n        }\n        const maskBlockSizes = [];\n        for (let i = 0; i < maskBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            maskBlockSizes.push(elt);\n        }\n        const reserved = dataView.getInt32(offset, le);\n        return {\n            maskBlockCount,\n            maskBlockSizes,\n            maskBlockStarts,\n            reserved,\n        };\n    }\n    async _getSequenceRecord(offset) {\n        const rec1 = await this._record1(offset);\n        const rec2DataLen = rec1.nBlockCount * 8 + 8;\n        const rec2 = await this._record2(offset + 4, rec2DataLen);\n        const rec3DataLen = rec2.maskBlockCount * 8 + 8;\n        const rec3 = await this._record3(offset + 4 + rec2DataLen - 4, rec3DataLen);\n        const rec = {\n            dnaSize: rec1.dnaSize,\n            nBlocks: {\n                starts: rec2.nBlockStarts,\n                sizes: rec2.nBlockSizes,\n            },\n            maskBlocks: {\n                starts: rec3.maskBlockStarts,\n                sizes: rec3.maskBlockSizes,\n            },\n            dnaPosition: offset + 4 + rec2DataLen - 4 + rec3DataLen,\n        };\n        return rec;\n    }\n    /**\n     * @param {string} seqName name of the sequence you want\n     * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.\n     * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence\n     * @returns {Promise} for a string of sequence bases\n     */\n    async getSequence(seqName, regionStart = 0, regionEnd = Number.POSITIVE_INFINITY) {\n        const index = await this.getIndex();\n        const offset = index[seqName];\n        if (!offset) {\n            return undefined;\n        }\n        // fetch the record for the seq\n        const record = await this._getSequenceRecord(offset);\n        if (regionStart < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        // end defaults to the end of the sequence\n        if (regionEnd > record.dnaSize) {\n            regionEnd = record.dnaSize;\n        }\n        const nBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.nBlocks.starts, record.nBlocks.sizes);\n        const maskBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.maskBlocks.starts, record.maskBlocks.sizes);\n        const baseBytes = Buffer.allocUnsafe(Math.ceil((regionEnd - regionStart) / 4) + 1);\n        const baseBytesOffset = Math.floor(regionStart / 4);\n        const { buffer } = await this.filehandle.read(baseBytes, 0, baseBytes.length, record.dnaPosition + baseBytesOffset);\n        let sequenceBases = '';\n        for (let genomicPosition = regionStart; genomicPosition < regionEnd; genomicPosition += 1) {\n            // check whether we are currently masked\n            while (maskBlocks.length > 0 && maskBlocks[0].end <= genomicPosition) {\n                maskBlocks.shift();\n            }\n            const baseIsMasked = maskBlocks[0] &&\n                maskBlocks[0].start <= genomicPosition &&\n                maskBlocks[0].end > genomicPosition;\n            // process the N block if we have one\n            if (nBlocks[0] &&\n                genomicPosition >= nBlocks[0].start &&\n                genomicPosition < nBlocks[0].end) {\n                const currentNBlock = nBlocks.shift();\n                for (; genomicPosition < currentNBlock.end && genomicPosition < regionEnd; genomicPosition += 1) {\n                    sequenceBases += baseIsMasked ? 'n' : 'N';\n                }\n                genomicPosition -= 1;\n            }\n            else {\n                const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;\n                const subPosition = genomicPosition % 4;\n                const byte = buffer[bytePosition];\n                sequenceBases += baseIsMasked\n                    ? maskedByteTo4Bases[byte][subPosition]\n                    : byteTo4Bases[byte][subPosition];\n            }\n        }\n        return sequenceBases;\n    }\n    _getOverlappingBlocks(regionStart, regionEnd, blockStarts, blockSizes) {\n        // find the start and end indexes of the blocks that match\n        let startIndex;\n        let endIndex;\n        for (const [index, blockStart] of blockStarts.entries()) {\n            const blockSize = blockSizes[index];\n            if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n                // block does not overlap the region\n                if (startIndex !== undefined) {\n                    endIndex = index;\n                    break;\n                }\n            }\n            else if (startIndex === undefined) {\n                startIndex = index;\n            } // block does overlap the region, record this if it is the first\n        }\n        if (startIndex === undefined) {\n            return [];\n        }\n        // now format some block objects to return\n        if (endIndex === undefined) {\n            endIndex = blockStarts.length;\n        }\n        const blocks = new Array(endIndex - startIndex);\n        for (let blockNumber = startIndex; blockNumber < endIndex; blockNumber += 1) {\n            blocks[blockNumber - startIndex] = {\n                start: blockStarts[blockNumber],\n                end: blockStarts[blockNumber] + blockSizes[blockNumber],\n                size: blockSizes[blockNumber],\n            };\n        }\n        return blocks;\n    }\n}\n//# sourceMappingURL=twoBitFile.js.map","import { TwoBitFile } from '@gmod/twobit';\nimport { readConfObject } from '@jbrowse/core/configuration';\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nexport default class TwoBitAdapter extends BaseSequenceAdapter {\n    async initChromSizes() {\n        const conf = readConfObject(this.config, 'chromSizesLocation');\n        if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {\n            const file = openLocation(conf, this.pluginManager);\n            const data = await file.readFile('utf8');\n            return Object.fromEntries(data\n                .split(/\\n|\\r\\n|\\r/)\n                .filter(line => !!line.trim())\n                .map(line => {\n                const [name, length] = line.split('\\t');\n                return [name, +length];\n            }));\n        }\n        return undefined;\n    }\n    async setupPre() {\n        return {\n            twobit: new TwoBitFile({\n                filehandle: openLocation(this.getConf('twoBitLocation'), this.pluginManager),\n            }),\n            chromSizesData: await this.initChromSizes(),\n        };\n    }\n    async setup() {\n        if (!this.setupP) {\n            this.setupP = this.setupPre().catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async getRefNames() {\n        const { chromSizesData, twobit } = await this.setup();\n        return chromSizesData\n            ? Object.keys(chromSizesData)\n            : twobit.getSequenceNames();\n    }\n    async getRegions() {\n        const { chromSizesData, twobit } = await this.setup();\n        if (chromSizesData) {\n            return Object.keys(chromSizesData).map(refName => ({\n                refName,\n                start: 0,\n                end: chromSizesData[refName],\n            }));\n        }\n        else {\n            const refSizes = await twobit.getSequenceSizes();\n            return Object.keys(refSizes).map(refName => ({\n                refName,\n                start: 0,\n                end: refSizes[refName],\n            }));\n        }\n    }\n    getFeatures({ refName, start, end }) {\n        return ObservableCreate(async (observer) => {\n            const { twobit } = await this.setup();\n            const size = await twobit.getSequenceSize(refName);\n            const regionEnd = size !== undefined ? Math.min(size, end) : end;\n            const seq = await twobit.getSequence(refName, start, regionEnd);\n            if (seq) {\n                observer.next(new SimpleFeature({\n                    id: `${refName} ${start}-${regionEnd}`,\n                    data: { refName, start, end: regionEnd, seq },\n                }));\n            }\n            observer.complete();\n        });\n    }\n    freeResources() { }\n}\n"],"names":["BigInt32","getBigInt64","dataView","byteOffset","littleEndian","littleEndianMask","bigEndianMask","getBigUint64","a","b","TWOBIT_MAGIC","twoBit","byteTo4Bases","index","maskedByteTo4Bases","bases","TwoBitFile","filehandle","path","LocalFile","returnValue","Buffer","buffer","error","le","offset","magic","version","sequenceCount","reserved","header","maxIndexLength","indexData","i","nameLength","name","dataOffset","seqNames","sizePromises","sizes","returnObject","index_","seqName","f","offset2","len","dnaSize","nBlockCount","nBlockStarts","elt","nBlockSizes","maskBlockCount","maskBlockStarts","maskBlockSizes","rec1","rec2DataLen","rec2","rec3DataLen","rec3","regionStart","regionEnd","record","nBlocks","maskBlocks","baseBytes","baseBytesOffset","sequenceBases","genomicPosition","baseIsMasked","currentNBlock","bytePosition","subPosition","byte","blockStarts","blockSizes","startIndex","endIndex","blockStart","blockSize","blocks","blockNumber","TwoBitAdapter","BaseSequenceAdapter","conf","readConfObject","data","openLocation","line","length","chromSizesData","twobit","refName","refSizes","start","end","ObservableCreate","observer","size","seq","SimpleFeature"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}