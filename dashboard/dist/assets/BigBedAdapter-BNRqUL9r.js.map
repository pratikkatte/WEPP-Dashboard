{"version":3,"file":"BigBedAdapter-BNRqUL9r.js","sources":["../../node_modules/@gmod/bbi/esm/bigbed.js","../../node_modules/@jbrowse/plugin-bed/esm/BigBedAdapter/BigBedAdapter.js"],"sourcesContent":["import { Buffer } from 'buffer';\nimport { Observable, merge, firstValueFrom } from 'rxjs';\nimport { map, reduce } from 'rxjs/operators';\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport QuickLRU from 'quick-lru';\n// locals\nimport { BBI } from './bbi';\nexport function filterUndef(ts) {\n    return ts.filter((t) => !!t);\n}\nexport class BigBed extends BBI {\n    constructor() {\n        super(...arguments);\n        this.readIndicesCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: 1 }),\n            fill: (args, signal) => this._readIndices({ ...args, signal }),\n        });\n    }\n    readIndices(opts = {}) {\n        const { signal, ...rest } = opts;\n        return this.readIndicesCache.get(JSON.stringify(rest), opts, signal);\n    }\n    /*\n     * retrieve unzoomed view for any scale\n     */\n    async getView(_scale, opts) {\n        return this.getUnzoomedView(opts);\n    }\n    /*\n     * parse the bigbed extraIndex fields\n     *\n     *\n     * @return a Promise for an array of Index data structure since there can be\n     * multiple extraIndexes in a bigbed, see bedToBigBed documentation\n     */\n    async _readIndices(opts) {\n        const { extHeaderOffset, isBigEndian } = await this.getHeader(opts);\n        const { buffer: data } = await this.bbi.read(Buffer.alloc(64), 0, 64, Number(extHeaderOffset));\n        const le = !isBigEndian;\n        const b = data;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        // const _size = dataView.getUint16(offset, le)\n        offset += 2;\n        const count = dataView.getUint16(offset, le);\n        offset += 2;\n        const dataOffset = Number(dataView.getBigUint64(offset, le));\n        offset += 8;\n        // no extra index is defined if count==0\n        if (count === 0) {\n            return [];\n        }\n        const blocklen = 20;\n        const len = blocklen * count;\n        const { buffer } = await this.bbi.read(Buffer.alloc(len), 0, len, Number(dataOffset));\n        const indices = [];\n        for (let i = 0; i < count; i += 1) {\n            const b = buffer.subarray(i * blocklen);\n            const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n            let offset = 0;\n            const type = dataView.getInt16(offset, le);\n            offset += 2;\n            const fieldcount = dataView.getInt16(offset, le);\n            offset += 2;\n            const dataOffset = Number(dataView.getBigUint64(offset, le));\n            offset += 8 + 4; //4 skip\n            const field = dataView.getInt16(offset, le);\n            indices.push({ type, fieldcount, offset: Number(dataOffset), field });\n        }\n        return indices;\n    }\n    /*\n     * perform a search in the bigbed extraIndex to find which blocks in the\n     * bigbed data to look for the actual feature data\n     *\n     * @param name - the name to search for\n     * @param opts - a SearchOptions argument with optional signal\n     * @return a Promise for an array of bigbed block Loc entries\n     */\n    async searchExtraIndexBlocks(name, opts = {}) {\n        const { isBigEndian } = await this.getHeader(opts);\n        const indices = await this.readIndices(opts);\n        if (indices.length === 0) {\n            return [];\n        }\n        const locs = indices.map(async (index) => {\n            const { offset: offset2, field } = index;\n            const { buffer: data } = await this.bbi.read(Buffer.alloc(32), 0, 32, offset2, opts);\n            const le = !isBigEndian;\n            const b = data;\n            const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n            let offset = 0;\n            // const _magic = dataView.getInt32(offset, le)\n            offset += 4;\n            const blockSize = dataView.getInt32(offset, le);\n            offset += 4;\n            const keySize = dataView.getInt32(offset, le);\n            offset += 4;\n            const valSize = dataView.getInt32(offset, le);\n            offset += 4;\n            // const _itemCount = Number(dataView.getBigUint64(offset, le))\n            offset += 8;\n            const bptReadNode = async (nodeOffset) => {\n                const val = Number(nodeOffset);\n                const len = 4 + blockSize * (keySize + valSize);\n                const { buffer } = await this.bbi.read(Buffer.alloc(len), 0, len, val, opts);\n                const b = buffer;\n                const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n                let offset = 0;\n                const nodeType = dataView.getInt8(offset);\n                offset += 2; //skip 1\n                const cnt = dataView.getInt16(offset, le);\n                offset += 2;\n                const keys = [];\n                if (nodeType === 0) {\n                    const leafkeys = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const key = b\n                            .subarray(offset, offset + keySize)\n                            .toString()\n                            .replaceAll('\\0', '');\n                        offset += keySize;\n                        const dataOffset = Number(dataView.getBigUint64(offset, le));\n                        offset += 8;\n                        leafkeys.push({ key, offset: dataOffset });\n                    }\n                    let lastOffset = 0;\n                    for (const { key, offset } of leafkeys) {\n                        if (name.localeCompare(key) < 0 && lastOffset) {\n                            return bptReadNode(lastOffset);\n                        }\n                        lastOffset = offset;\n                    }\n                    return bptReadNode(lastOffset);\n                }\n                else if (nodeType === 1) {\n                    for (let i = 0; i < cnt; i++) {\n                        const key = b\n                            .subarray(offset, offset + keySize)\n                            .toString()\n                            .replaceAll('\\0', '');\n                        offset += keySize;\n                        const dataOffset = Number(dataView.getBigUint64(offset, le));\n                        offset += 8;\n                        const length = dataView.getUint32(offset, le);\n                        offset += 4;\n                        const reserved = dataView.getUint32(offset, le);\n                        offset += 4;\n                        keys.push({ key, offset: dataOffset, length, reserved });\n                    }\n                    for (const n of keys) {\n                        if (n.key === name) {\n                            return { ...n, field };\n                        }\n                    }\n                    return undefined;\n                }\n            };\n            const rootNodeOffset = 32;\n            return bptReadNode(offset2 + rootNodeOffset);\n        });\n        return filterUndef(await Promise.all(locs));\n    }\n    /*\n     * retrieve the features from the bigbed data that were found through the\n     * lookup of the extraIndex note that there can be multiple extraIndex, see\n     * the BigBed specification and the -extraIndex argument to bedToBigBed\n     *\n     * @param name - the name to search for\n     * @param opts - a SearchOptions argument with optional signal\n     * @return a Promise for an array of Feature\n     */\n    async searchExtraIndex(name, opts = {}) {\n        const blocks = await this.searchExtraIndexBlocks(name, opts);\n        if (blocks.length === 0) {\n            return [];\n        }\n        const view = await this.getUnzoomedView(opts);\n        const res = blocks.map(block => {\n            return new Observable(observer => {\n                view.readFeatures(observer, [block], opts).catch((e) => {\n                    observer.error(e);\n                });\n            }).pipe(reduce((acc, curr) => acc.concat(curr)), map(x => {\n                for (const element of x) {\n                    element.field = block.field;\n                }\n                return x;\n            }));\n        });\n        const ret = await firstValueFrom(merge(...res));\n        return ret.filter(f => { var _a; return ((_a = f.rest) === null || _a === void 0 ? void 0 : _a.split('\\t')[(f.field || 0) - 3]) === name; });\n    }\n}\n//# sourceMappingURL=bigbed.js.map","import { BigBed } from '@gmod/bbi';\nimport BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, doesIntersect2, max, min } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { firstValueFrom, toArray } from 'rxjs';\nimport { featureData2 } from '../util';\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n    async configurePre(opts) {\n        const pm = this.pluginManager;\n        const bigbed = new BigBed({\n            filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n        });\n        const header = await bigbed.getHeader(opts);\n        const parser = new BED({\n            autoSql: header.autoSql,\n        });\n        return {\n            bigbed,\n            header,\n            parser,\n        };\n    }\n    async configure(opts) {\n        if (!this.cachedP) {\n            this.cachedP = this.configurePre(opts).catch((e) => {\n                this.cachedP = undefined;\n                throw e;\n            });\n        }\n        return this.cachedP;\n    }\n    async getRefNames(opts) {\n        const { header } = await this.configure(opts);\n        return Object.keys(header.refsByName);\n    }\n    async getData() {\n        const refNames = await this.getRefNames();\n        const features = [];\n        for (const refName of refNames) {\n            const f = await firstValueFrom(this.getFeatures({\n                assemblyName: 'unknown',\n                refName,\n                start: 0,\n                end: Number.MAX_SAFE_INTEGER,\n            }).pipe(toArray()));\n            features.push(f);\n        }\n        return features.flat();\n    }\n    async getHeader(opts) {\n        const { parser, header } = await this.configure(opts);\n        const { version, fileType } = header;\n        const { fields, ...rest } = parser.autoSql;\n        return {\n            version,\n            fileType,\n            autoSql: { ...rest },\n            fields: Object.fromEntries(fields.map(({ name, comment }) => [name, comment])),\n        };\n    }\n    async getFeaturesHelper({ query, opts, observer, allowRedispatch, originalQuery = query, }) {\n        var _a;\n        const { stopToken } = opts;\n        const scoreColumn = this.getConf('scoreColumn');\n        const aggregateField = this.getConf('aggregateField');\n        const { parser, bigbed } = await this.configure(opts);\n        const feats = await bigbed.getFeatures(query.refName, query.start, query.end, {\n            stopToken,\n            basesPerSpan: query.end - query.start,\n        });\n        if (allowRedispatch && feats.length) {\n            let minStart = Number.POSITIVE_INFINITY;\n            let maxEnd = Number.NEGATIVE_INFINITY;\n            for (const feat of feats) {\n                if (feat.start < minStart) {\n                    minStart = feat.start;\n                }\n                if (feat.end > maxEnd) {\n                    maxEnd = feat.end;\n                }\n            }\n            if (maxEnd > query.end || minStart < query.start) {\n                await this.getFeaturesHelper({\n                    query: {\n                        ...query,\n                        start: minStart,\n                        end: maxEnd,\n                    },\n                    opts,\n                    observer,\n                    allowRedispatch: false,\n                    originalQuery: query,\n                });\n                return;\n            }\n        }\n        const parentAggregation = {};\n        if (feats.some(f => f.uniqueId === undefined)) {\n            throw new Error('found uniqueId undefined');\n        }\n        for (const feat of feats) {\n            const splitLine = [\n                query.refName,\n                `${feat.start}`,\n                `${feat.end}`,\n                ...(((_a = feat.rest) === null || _a === void 0 ? void 0 : _a.split('\\t')) || []),\n            ];\n            const data = parser.parseLine(splitLine, { uniqueId: feat.uniqueId });\n            const aggr = data[aggregateField];\n            if (!parentAggregation[aggr]) {\n                parentAggregation[aggr] = [];\n            }\n            const { uniqueId, type, chrom, chromStart, chromEnd, description, chromStarts: chromStarts2, blockStarts: blockStarts2, blockSizes: blockSizes2, score: score2, blockCount, thickStart, thickEnd, strand, ...rest } = data;\n            const f = featureData2({\n                ...rest,\n                scoreColumn,\n                splitLine,\n                parser,\n                uniqueId,\n                start: feat.start,\n                end: feat.end,\n                refName: query.refName,\n            });\n            if (aggr) {\n                parentAggregation[aggr].push(f);\n            }\n            else {\n                if (doesIntersect2(f.start, f.end, originalQuery.start, originalQuery.end)) {\n                    observer.next(new SimpleFeature({\n                        id: `${this.id}-${uniqueId}`,\n                        data: f,\n                    }));\n                }\n            }\n        }\n        Object.entries(parentAggregation).map(([name, subfeatures]) => {\n            const s = min(subfeatures.map(f => f.start));\n            const e = max(subfeatures.map(f => f.end));\n            if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n                const { uniqueId, strand } = subfeatures[0];\n                observer.next(new SimpleFeature({\n                    id: `${this.id}-${uniqueId}-parent`,\n                    data: {\n                        type: 'gene',\n                        subfeatures,\n                        strand,\n                        name,\n                        start: s,\n                        end: e,\n                        refName: query.refName,\n                    },\n                }));\n            }\n        });\n        observer.complete();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            try {\n                await this.getFeaturesHelper({\n                    query,\n                    opts,\n                    observer,\n                    allowRedispatch: true,\n                });\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n    freeResources() { }\n}\n"],"names":["filterUndef","ts","t","BigBed","BBI","AbortablePromiseCache","QuickLRU","args","signal","opts","rest","_scale","extHeaderOffset","isBigEndian","data","Buffer","le","b","dataView","offset","count","dataOffset","blocklen","len","buffer","indices","i","type","fieldcount","field","name","locs","index","offset2","blockSize","keySize","valSize","bptReadNode","nodeOffset","val","nodeType","cnt","keys","leafkeys","key","lastOffset","length","reserved","n","blocks","view","res","block","Observable","observer","e","reduce","acc","curr","map","x","element","firstValueFrom","merge","f","_a","BigBedAdapter","BaseFeatureDataAdapter","pm","bigbed","openLocation","header","parser","BED","refNames","features","refName","toArray","version","fileType","fields","comment","query","allowRedispatch","originalQuery","stopToken","scoreColumn","aggregateField","feats","minStart","maxEnd","feat","parentAggregation","splitLine","aggr","uniqueId","chrom","chromStart","chromEnd","description","chromStarts2","blockStarts2","blockSizes2","score2","blockCount","thickStart","thickEnd","strand","featureData2","doesIntersect2","SimpleFeature","subfeatures","s","min","max","ObservableCreate"],"mappings":"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","x_google_ignoreList":[0,1]}