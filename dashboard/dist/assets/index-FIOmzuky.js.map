{"version":3,"file":"index-FIOmzuky.js","sources":["../../node_modules/@gmod/vcf/esm/parseGenotypesOnly.js","../../node_modules/@gmod/vcf/esm/parseMetaString.js","../../node_modules/@gmod/vcf/esm/vcfReserved.js","../../node_modules/@gmod/vcf/esm/parse.js","../../node_modules/@jbrowse/plugin-variants/esm/VcfFeature/util.js","../../node_modules/@jbrowse/plugin-variants/esm/VcfFeature/index.js"],"sourcesContent":["export function parseGenotypesOnly(format, prerest, samples) {\n    const rest = prerest.split('\\t');\n    const genotypes = {};\n    let i = 0;\n    if (format.includes('GT')) {\n        const formatSplit = format.split(':');\n        if (formatSplit.length === 1) {\n            for (const sample of samples) {\n                genotypes[sample] = rest[i++];\n            }\n        }\n        else {\n            const gtIndex = formatSplit.indexOf('GT');\n            if (gtIndex === 0) {\n                for (const sample of samples) {\n                    const val = rest[i++];\n                    const idx = val.indexOf(':');\n                    genotypes[sample] = idx !== -1 ? val.slice(0, idx) : val;\n                }\n            }\n            else {\n                for (const sample of samples) {\n                    const val = rest[i++].split(':');\n                    genotypes[sample] = val[gtIndex];\n                }\n            }\n        }\n    }\n    return genotypes;\n}\n//# sourceMappingURL=parseGenotypesOnly.js.map","// constructed with the assistance of claude AI\n//\n// I first prompted it with a regex that splits a comma separated string with\n// awareness of quotation from this stackoverflow queston\n// https://stackoverflow.com/a/18893443/2129219, and asked it to add support\n// for square brackets\n//\n// it undid the regex into serial logic and the result was this function\nfunction customSplit(str) {\n    const result = [];\n    let current = '';\n    let inQuotes = false;\n    let inBrackets = false;\n    for (const char of str) {\n        if (char === '\"') {\n            inQuotes = !inQuotes;\n            current += char;\n        }\n        else if (char === '[') {\n            inBrackets = true;\n            current += char;\n        }\n        else if (char === ']') {\n            inBrackets = false;\n            current += char;\n        }\n        else if (char === ',' && !inQuotes && !inBrackets) {\n            result.push(current.trim());\n            current = '';\n        }\n        else {\n            current += char;\n        }\n    }\n    if (current) {\n        result.push(current.trim());\n    }\n    return result;\n}\nfunction splitFirst(str, split) {\n    const index = str.indexOf(split);\n    return [str.slice(0, index), str.slice(index + 1)];\n}\nexport function parseMetaString(metaString) {\n    const inside = metaString.replace(/^<|>$/g, '');\n    return Object.fromEntries(customSplit(inside).map(f => {\n        const [key, val] = splitFirst(f, '=');\n        if (val && val.startsWith('[') && val.endsWith(']')) {\n            return [\n                key,\n                val\n                    .slice(1, -1)\n                    .split(',')\n                    .map(f => f.trim()),\n            ];\n        }\n        else if (val && val.startsWith('\"') && val.endsWith('\"')) {\n            return [key, val.slice(1, -1)];\n        }\n        else {\n            return [key, val?.replaceAll(/^\"|\"$/g, '')];\n        }\n    }));\n}\n//# sourceMappingURL=parseMetaString.js.map","export default {\n    // INFO fields\n    InfoFields: {\n        // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n        AA: { Number: 1, Type: 'String', Description: 'Ancestral allele' },\n        AC: {\n            Number: 'A',\n            Type: 'Integer',\n            Description: 'Allele count in genotypes, for each ALT allele, in the same order as listed',\n        },\n        AD: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Total read depth for each allele',\n        },\n        ADF: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the forward strand',\n        },\n        ADR: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the reverse strand',\n        },\n        AF: {\n            Number: 'A',\n            Type: 'Float',\n            Description: 'Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)',\n        },\n        AN: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Total number of alleles in called genotypes',\n        },\n        BQ: {\n            Number: 1,\n            Type: 'Float',\n            Description: 'RMS base quality',\n        },\n        CIGAR: {\n            Number: 1,\n            Type: 'Float',\n            Description: 'Cigar string describing how to align an alternate allele to the reference allele',\n        },\n        DB: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'dbSNP membership',\n        },\n        DP: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'combined depth across samples',\n        },\n        END: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'End position (for use with symbolic alleles)',\n        },\n        H2: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'HapMap2 membership',\n        },\n        H3: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'HapMap3 membership',\n        },\n        MQ: {\n            Number: 1,\n            Type: null,\n            Description: 'RMS mapping quality',\n        },\n        MQ0: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Number of MAPQ == 0 reads',\n        },\n        NS: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Number of samples with data',\n        },\n        SB: {\n            Number: 4,\n            Type: 'Integer',\n            Description: 'Strand bias',\n        },\n        SOMATIC: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Somatic mutation (for cancer genomics)',\n        },\n        VALIDATED: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Validated by follow-up experiment',\n        },\n        '1000G': {\n            Number: 0,\n            Type: 'Flag',\n            Description: '1000 Genomes membership',\n        },\n        // specifically for structural variants\n        IMPRECISE: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Imprecise structural variation',\n        },\n        NOVEL: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Indicates a novel structural variation',\n        },\n        // For precise variants, END is POS + length of REF allele - 1,\n        // and the for imprecise variants the corresponding best estimate.\n        SVTYPE: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Type of structural variant',\n        },\n        // Value should be one of DEL, INS, DUP, INV, CNV, BND. This key can\n        // be derived from the REF/ALT fields but is useful for filtering.\n        SVLEN: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Difference in length between REF and ALT alleles',\n        },\n        // One value for each ALT allele. Longer ALT alleles (e.g. insertions)\n        // have positive values, shorter ALT alleles (e.g. deletions)\n        // have negative values.\n        CIPOS: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around POS for imprecise variants',\n        },\n        CIEND: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around END for imprecise variants',\n        },\n        HOMLEN: {\n            Type: 'Integer',\n            Description: 'Length of base pair identical micro-homology at event breakpoints',\n        },\n        HOMSEQ: {\n            Type: 'String',\n            Description: 'Sequence of base pair identical micro-homology at event breakpoints',\n        },\n        BKPTID: {\n            Type: 'String',\n            Description: 'ID of the assembled alternate allele in the assembly file',\n        },\n        // For precise variants, the consensus sequence the alternate allele assembly\n        // is derivable from the REF and ALT fields. However, the alternate allele\n        // assembly file may contain additional information about the characteristics\n        // of the alt allele contigs.\n        MEINFO: {\n            Number: 4,\n            Type: 'String',\n            Description: 'Mobile element info of the form NAME,START,END,POLARITY',\n        },\n        METRANS: {\n            Number: 4,\n            Type: 'String',\n            Description: 'Mobile element transduction info of the form CHR,START,END,POLARITY',\n        },\n        DGVID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in Database of Genomic Variation',\n        },\n        DBVARID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in DBVAR',\n        },\n        DBRIPID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in DBRIP',\n        },\n        MATEID: {\n            Number: null,\n            Type: 'String',\n            Description: 'ID of mate breakends',\n        },\n        PARID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of partner breakend',\n        },\n        EVENT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of event associated to breakend',\n        },\n        CILEN: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around the inserted material between breakend',\n        },\n        DPADJ: { Type: 'Integer', Description: 'Read Depth of adjacency' },\n        CN: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Copy number of segment containing breakend',\n        },\n        CNADJ: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Copy number of adjacency',\n        },\n        CICN: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around copy number for the segment',\n        },\n        CICNADJ: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Confidence interval around copy number for the adjacency',\n        },\n    },\n    // FORMAT fields\n    GenotypeFields: {\n        // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n        AD: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele',\n        },\n        ADF: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the forward strand',\n        },\n        ADR: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the reverse strand',\n        },\n        DP: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Read depth',\n        },\n        EC: {\n            Number: 'A',\n            Type: 'Integer',\n            Description: 'Expected alternate allele counts',\n        },\n        FT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Filter indicating if this genotype was \"called\"',\n        },\n        GL: {\n            Number: 'G',\n            Type: 'Float',\n            Description: 'Genotype likelihoods',\n        },\n        GP: {\n            Number: 'G',\n            Type: 'Float',\n            Description: 'Genotype posterior probabilities',\n        },\n        GQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Conditional genotype quality',\n        },\n        GT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Genotype',\n        },\n        HQ: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Haplotype quality',\n        },\n        MQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'RMS mapping quality',\n        },\n        PL: {\n            Number: 'G',\n            Type: 'Integer',\n            Description: 'Phred-scaled genotype likelihoods rounded to the closest integer',\n        },\n        PQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Phasing quality',\n        },\n        PS: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Phase set',\n        },\n    },\n    // ALT fields\n    AltTypes: {\n        DEL: {\n            Description: 'Deletion relative to the reference',\n        },\n        INS: {\n            Description: 'Insertion of novel sequence relative to the reference',\n        },\n        DUP: {\n            Description: 'Region of elevated copy number relative to the reference',\n        },\n        INV: {\n            Description: 'Inversion of reference sequence',\n        },\n        CNV: {\n            Description: 'Copy number variable region (may be both deletion and duplication)',\n        },\n        'DUP:TANDEM': {\n            Description: 'Tandem duplication',\n        },\n        'DEL:ME': {\n            Description: 'Deletion of mobile element relative to the reference',\n        },\n        'INS:ME': {\n            Description: 'Insertion of a mobile element relative to the reference',\n        },\n        NON_REF: {\n            Description: 'Represents any possible alternative allele at this location',\n        },\n        '*': {\n            Description: 'Represents any possible alternative allele at this location',\n        },\n    },\n    // FILTER fields\n    FilterTypes: {\n        PASS: {\n            Description: 'Passed all filters',\n        },\n    },\n};\n//# sourceMappingURL=vcfReserved.js.map","import { parseGenotypesOnly } from \"./parseGenotypesOnly.js\";\nimport { parseMetaString } from \"./parseMetaString.js\";\nimport vcfReserved from \"./vcfReserved.js\";\nfunction decodeURIComponentNoThrow(uri) {\n    try {\n        return decodeURIComponent(uri);\n    }\n    catch (_e) {\n        // avoid throwing exception on a failure to decode URI component\n        return uri;\n    }\n}\n/**\n * Class representing a VCF parser, instantiated with the VCF header.\n *\n * @param {object} args\n *\n * @param {string} args.header - The VCF header. Supports both LF and CRLF\n * newlines.\n *\n * @param {boolean} args.strict - Whether to parse in strict mode or not\n * (default true)\n */\nexport default class VCFParser {\n    constructor({ header = '', strict = true, }) {\n        if (!header.length) {\n            throw new Error('empty header received');\n        }\n        const headerLines = header.split(/[\\r\\n]+/).filter(Boolean);\n        if (!headerLines.length) {\n            throw new Error('no non-empty header lines specified');\n        }\n        this.strict = strict;\n        this.metadata = JSON.parse(JSON.stringify({\n            INFO: vcfReserved.InfoFields,\n            FORMAT: vcfReserved.GenotypeFields,\n            ALT: vcfReserved.AltTypes,\n            FILTER: vcfReserved.FilterTypes,\n        }));\n        let lastLine;\n        headerLines.forEach(line => {\n            if (!line.startsWith('#')) {\n                throw new Error(`Bad line in header:\\n${line}`);\n            }\n            else if (line.startsWith('##')) {\n                this.parseMetadata(line);\n            }\n            else {\n                lastLine = line;\n            }\n        });\n        if (!lastLine) {\n            throw new Error('No format line found in header');\n        }\n        const fields = lastLine.trim().split('\\t');\n        const thisHeader = fields.slice(0, 8);\n        const correctHeader = [\n            '#CHROM',\n            'POS',\n            'ID',\n            'REF',\n            'ALT',\n            'QUAL',\n            'FILTER',\n            'INFO',\n        ];\n        if (fields.length < 8) {\n            throw new Error(`VCF header missing columns:\\n${lastLine}`);\n        }\n        else if (thisHeader.length !== correctHeader.length ||\n            !thisHeader.every((value, index) => value === correctHeader[index])) {\n            throw new Error(`VCF column headers not correct:\\n${lastLine}`);\n        }\n        this.samples = fields.slice(9);\n    }\n    parseSamples(format, prerest) {\n        const genotypes = {};\n        if (format) {\n            const rest = prerest.split('\\t');\n            const formatKeys = format.split(':');\n            const isNumberType = formatKeys.map(key => {\n                const r = this.getMetadata('FORMAT', key, 'Type');\n                return r === 'Integer' || r === 'Float';\n            });\n            for (let i = 0; i < this.samples.length; i++) {\n                const sample = this.samples[i];\n                genotypes[sample] = {};\n                const columns = rest[i].split(':');\n                for (let j = 0; j < columns.length; j++) {\n                    const val = columns[j];\n                    genotypes[sample][formatKeys[j]] =\n                        val === '' || val === '.'\n                            ? undefined\n                            : val\n                                .split(',')\n                                .map(ent => ent === '.' ? undefined : isNumberType[j] ? +ent : ent);\n                }\n            }\n        }\n        return genotypes;\n    }\n    /**\n     * Parse a VCF metadata line (i.e. a line that starts with \"##\") and add its\n     * properties to the object.\n     *\n     * @param {string} line - A line from the VCF. Supports both LF and CRLF\n     * newlines.\n     */\n    parseMetadata(line) {\n        const match = /^##(.+?)=(.*)/.exec(line.trim());\n        if (!match) {\n            throw new Error(`Line is not a valid metadata line: ${line}`);\n        }\n        const [metaKey, metaVal] = match.slice(1, 3);\n        const r = metaKey;\n        if (metaVal?.startsWith('<')) {\n            if (!(r in this.metadata)) {\n                this.metadata[r] = {};\n            }\n            const [id, keyVals] = this.parseStructuredMetaVal(metaVal);\n            if (id) {\n                // if there is an ID field in the <> metadata\n                // e.g. ##INFO=<ID=AF_ESP,...>\n                ;\n                this.metadata[r][id] = keyVals;\n            }\n            else {\n                // if there is not an ID field in the <> metadata\n                // e.g. ##ID=<Description=\"ClinVar Variation ID\">\n                this.metadata[r] = keyVals;\n            }\n        }\n        else {\n            this.metadata[r] = metaVal;\n        }\n    }\n    /**\n     * Parse a VCF header structured meta string (i.e. a meta value that starts\n     * with \"<ID=...\")\n     *\n     * @param {string} metaVal - The VCF metadata value\n     *\n     * @returns {Array} - Array with two entries, 1) a string of the metadata ID\n     * and 2) an object with the other key-value pairs in the metadata\n     */\n    parseStructuredMetaVal(metaVal) {\n        const keyVals = parseMetaString(metaVal);\n        const id = keyVals.ID;\n        delete keyVals.ID;\n        if ('Number' in keyVals) {\n            if (!Number.isNaN(Number(keyVals.Number))) {\n                keyVals.Number = Number(keyVals.Number);\n            }\n        }\n        return [id, keyVals];\n    }\n    /**\n     * Get metadata filtered by the elements in args. For example, can pass\n     * ('INFO', 'DP') to only get info on an metadata tag that was like\n     * \"##INFO=<ID=DP,...>\"\n     *\n     * @param  {...string} args - List of metadata filter strings.\n     *\n     * @returns {any} An object, string, or number, depending on the filtering\n     */\n    getMetadata(...args) {\n        let filteredMetadata = this.metadata;\n        for (const arg of args) {\n            filteredMetadata = filteredMetadata[arg];\n            if (!filteredMetadata) {\n                return filteredMetadata;\n            }\n        }\n        return filteredMetadata;\n    }\n    /**\n     * Parse a VCF line into an object like\n     *\n     * ```typescript\n     * {\n     *   CHROM: 'contigA',\n     *   POS: 3000,\n     *   ID: ['rs17883296'],\n     *   REF: 'G',\n     *   ALT: ['T', 'A'],\n     *   QUAL: 100,\n     *   FILTER: 'PASS',\n     *   INFO: {\n     *     NS: [3],\n     *     DP: [14],\n     *     AF: [0.5],\n     *     DB: true,\n     *     XYZ: ['5'],\n     *   },\n     *   SAMPLES: () => ({\n     *     HG00096: {\n     *       GT: ['0|0'],\n     *       AP: ['0.000', '0.000'],\n     *     }\n     *   }),\n     *   GENOTYPES: () => ({\n     *     HG00096: '0|0'\n     *   })\n     * }\n     * ```\n     *\n     * SAMPLES and GENOTYPES methods are functions instead of static data fields\n     * because it avoids parsing the potentially long list of samples from e.g.\n     * 1000 genotypes data unless requested.\n     *\n     * The SAMPLES function gives all info about the samples\n     *\n     * The GENOTYPES function only extracts the raw GT string if it exists, for\n     * potentially optimized parsing by programs that need it\n     *\n     * @param {string} line - A string of a line from a VCF\n     */\n    parseLine(line) {\n        let currChar = 0;\n        for (let currField = 0; currChar < line.length; currChar += 1) {\n            if (line[currChar] === '\\t') {\n                currField += 1;\n            }\n            if (currField === 9) {\n                // reached genotypes, rest of fields are evaluated lazily\n                break;\n            }\n        }\n        const fields = line.slice(0, currChar).split('\\t');\n        const rest = line.slice(currChar + 1);\n        const [CHROM, POS, ID, REF, ALT, QUAL, FILTER] = fields;\n        const chrom = CHROM;\n        const pos = +POS;\n        const id = ID === '.' ? undefined : ID.split(';');\n        const ref = REF;\n        const alt = ALT === '.' ? undefined : ALT.split(',');\n        const qual = QUAL === '.' ? undefined : +QUAL;\n        const filter = FILTER === '.' ? undefined : FILTER.split(';');\n        const format = fields[8];\n        if (this.strict && !fields[7]) {\n            throw new Error(\"no INFO field specified, must contain at least a '.' (turn off strict mode to allow)\");\n        }\n        const hasDecode = fields[7]?.includes('%');\n        const info = fields[7] === undefined || fields[7] === '.'\n            ? {}\n            : Object.fromEntries(fields[7].split(';').map(r => {\n                const [key, val] = r.split('=');\n                const items = val\n                    ?.split(',')\n                    .map(val => (val === '.' ? undefined : val))\n                    .map(f => (f && hasDecode ? decodeURIComponentNoThrow(f) : f));\n                const itemType = this.getMetadata('INFO', key, 'Type');\n                if (itemType === 'Integer' || itemType === 'Float') {\n                    return [\n                        key,\n                        items?.map(val => val === undefined ? undefined : Number(val)),\n                    ];\n                }\n                else if (itemType === 'Flag') {\n                    return [key, true];\n                }\n                else {\n                    // ?? true interpret as flag if undefined\n                    return [key, items ?? true];\n                }\n            }));\n        return {\n            CHROM: chrom,\n            POS: pos,\n            ALT: alt,\n            INFO: info,\n            REF: ref,\n            FILTER: filter && filter.length === 1 && filter[0] === 'PASS' ? 'PASS' : filter,\n            ID: id,\n            QUAL: qual,\n            FORMAT: format,\n            SAMPLES: () => this.parseSamples(fields[8] ?? '', rest),\n            GENOTYPES: () => parseGenotypesOnly(fields[8] ?? '', rest, this.samples),\n        };\n    }\n}\n//# sourceMappingURL=parse.js.map","import { parseBreakend } from '@gmod/vcf';\nconst altTypeToSO = {\n    DEL: 'deletion',\n    INS: 'insertion',\n    DUP: 'duplication',\n    INV: 'inversion',\n    INVDUP: 'inverted_duplication',\n    CNV: 'copy_number_variation',\n    TRA: 'translocation',\n    'DUP:TANDEM': 'tandem_duplication',\n    NON_REF: 'sequence_variant',\n    '*': 'sequence_variant',\n};\nexport function getSOTermAndDescription(ref, alt, parser) {\n    if (!alt || alt.length === 0) {\n        return ['remark', 'no alternative alleles'];\n    }\n    const soTerms = new Set();\n    let descriptions = new Set();\n    alt.forEach(a => {\n        let [soTerm, description] = getSOAndDescFromAltDefs(a, parser);\n        if (!soTerm) {\n            ;\n            [soTerm, description] = getSOAndDescByExamination(ref, a);\n        }\n        if (soTerm && description) {\n            soTerms.add(soTerm);\n            descriptions.add(description);\n        }\n    });\n    if (descriptions.size > 1) {\n        const descs = [...descriptions];\n        const prefixes = new Set(descs\n            .map(desc => {\n            const prefix = desc.split('->');\n            return prefix[1] ? prefix[0] : desc;\n        })\n            .filter((f) => !!f));\n        descriptions = new Set([...prefixes]\n            .map(r => r.trim())\n            .map(prefix => {\n            const suffixes = descs\n                .map(desc => desc.split('->').map(r => r.trim()))\n                .map(pref => (pref[1] && pref[0] === prefix ? pref[1] : ''))\n                .filter(f => !!f);\n            return suffixes.length ? `${prefix} -> ${suffixes.join(',')}` : prefix;\n        }));\n    }\n    if (soTerms.size) {\n        return [[...soTerms].join(','), [...descriptions].join(',')];\n    }\n    return [];\n}\nexport function getSOAndDescFromAltDefs(alt, parser) {\n    if (typeof alt === 'string' && !alt.startsWith('<')) {\n        return [];\n    }\n    let soTerm = altTypeToSO[alt];\n    if (!soTerm && parser.getMetadata('ALT', alt)) {\n        soTerm = 'sequence_variant';\n    }\n    if (soTerm) {\n        return [soTerm, alt];\n    }\n    const modAlt = alt.split(':');\n    if (modAlt.length > 1) {\n        return getSOAndDescFromAltDefs(`<${modAlt.slice(0, -1).join(':')}>`, parser);\n    }\n    return [];\n}\nexport function getSOAndDescByExamination(ref, alt) {\n    const bnd = parseBreakend(alt);\n    if (bnd) {\n        return ['breakend', alt];\n    }\n    if (ref.length === 1 && alt.length === 1) {\n        return ['SNV', makeDescriptionString('SNV', ref, alt)];\n    }\n    if (alt === '<INS>') {\n        return ['insertion', alt];\n    }\n    if (alt === '<DEL>') {\n        return ['deletion', alt];\n    }\n    if (alt === '<DUP>') {\n        return ['duplication', alt];\n    }\n    if (alt === '<CNV>') {\n        return ['cnv', alt];\n    }\n    if (alt === '<INV>') {\n        return ['inversion', alt];\n    }\n    if (alt === '<TRA>') {\n        return ['translocation', alt];\n    }\n    if (alt.includes('<')) {\n        return ['sv', alt];\n    }\n    if (ref.length === alt.length) {\n        return ref.split('').reverse().join('') === alt\n            ? ['inversion', makeDescriptionString('inversion', ref, alt)]\n            : ['substitution', makeDescriptionString('substitution', ref, alt)];\n    }\n    if (ref.length <= alt.length) {\n        const len = alt.length - ref.length;\n        const lena = len.toLocaleString('en-US');\n        return [\n            'insertion',\n            len > 5 ? `${lena}bp INS` : makeDescriptionString('insertion', ref, alt),\n        ];\n    }\n    if (ref.length > alt.length) {\n        const len = ref.length - alt.length;\n        const lena = len.toLocaleString('en-US');\n        return [\n            'deletion',\n            len > 5 ? `${lena}bp DEL` : makeDescriptionString('deletion', ref, alt),\n        ];\n    }\n    return ['indel', makeDescriptionString('indel', ref, alt)];\n}\nfunction makeDescriptionString(soTerm, ref, alt) {\n    return `${soTerm} ${ref} -> ${alt}`;\n}\n","import { getSOTermAndDescription } from './util';\nfunction dataFromVariant(variant, parser) {\n    const { REF = '', ALT, POS, CHROM, ID } = variant;\n    const start = POS - 1;\n    const [type, description] = getSOTermAndDescription(REF, ALT, parser);\n    return {\n        refName: CHROM,\n        start,\n        end: getEnd(variant),\n        description,\n        type,\n        name: ID === null || ID === void 0 ? void 0 : ID.join(','),\n        aliases: ID && ID.length > 1 ? ID.slice(1) : undefined,\n    };\n}\nfunction getEnd(variant) {\n    const { POS, REF = '', ALT } = variant;\n    const isTRA = ALT === null || ALT === void 0 ? void 0 : ALT.includes('<TRA>');\n    const start = POS - 1;\n    const isSymbolic = ALT === null || ALT === void 0 ? void 0 : ALT.some(f => f.includes('<'));\n    if (isSymbolic) {\n        const info = variant.INFO;\n        if (info.END && !isTRA) {\n            return +info.END[0];\n        }\n    }\n    return start + REF.length;\n}\nexport default class VCFFeature {\n    constructor(args) {\n        this.variant = args.variant;\n        this.parser = args.parser;\n        this.data = dataFromVariant(this.variant, this.parser);\n        this._id = args.id;\n    }\n    get(field) {\n        var _a;\n        return field === 'samples'\n            ? this.variant.SAMPLES()\n            : field === 'genotypes'\n                ? this.variant.GENOTYPES()\n                : ((_a = this.data[field]) !== null && _a !== void 0 ? _a : this.variant[field]);\n    }\n    parent() {\n        return undefined;\n    }\n    children() {\n        return undefined;\n    }\n    id() {\n        return this._id;\n    }\n    toJSON() {\n        const { SAMPLES, GENOTYPES, ...rest } = this.variant;\n        return {\n            uniqueId: this._id,\n            ...rest,\n            ...this.data,\n            samples: this.variant.SAMPLES(),\n        };\n    }\n}\n"],"names":["parseGenotypesOnly","format","prerest","samples","rest","genotypes","i","formatSplit","sample","gtIndex","val","idx","customSplit","str","result","current","inQuotes","inBrackets","char","splitFirst","split","index","parseMetaString","metaString","inside","f","key","vcfReserved","decodeURIComponentNoThrow","uri","VCFParser","header","strict","headerLines","lastLine","line","fields","thisHeader","correctHeader","value","formatKeys","isNumberType","r","columns","j","ent","match","metaKey","metaVal","id","keyVals","args","filteredMetadata","arg","currChar","currField","CHROM","POS","ID","REF","ALT","QUAL","FILTER","chrom","pos","ref","alt","qual","filter","hasDecode","_a","info","items","itemType","altTypeToSO","getSOTermAndDescription","parser","soTerms","descriptions","a","soTerm","description","getSOAndDescFromAltDefs","getSOAndDescByExamination","descs","prefixes","desc","prefix","suffixes","pref","modAlt","parseBreakend","makeDescriptionString","len","lena","dataFromVariant","variant","start","type","getEnd","isTRA","VCFFeature","field","SAMPLES","GENOTYPES"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}