{"version":3,"file":"DashboardAdapter-DTx_LRDl.js","sources":["../../src/plugins/shared/util.ts","../../src/plugins/DashboardAdapter/BamSlightlyLazyFeature.ts","../../src/plugins/DashboardAdapter/DashboardAdapter.ts"],"sourcesContent":["import { ChainData } from './fetchChains'\n\nexport function hasPairedReads(features: ChainData) {\n  for (const f of features.chains.values()) {\n    if (f[0].flags & 1) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function filterReadFlag(\n  flags: number,\n  flagInclude: number,\n  flagExclude: number,\n) {\n  if ((flags & flagInclude) !== flagInclude) {\n    return true\n  } else if (flags & flagExclude) {\n    return true\n  } else {\n    return false\n  }\n}\n\nexport function filterTagValue(readVal: unknown, filterVal?: string) {\n  return filterVal === '*'\n    ? readVal === undefined\n    : `${readVal}` !== `${filterVal}`\n}\n\nexport function cacheGetter<T>(ctor: { prototype: T }, prop: keyof T): void {\n  const desc = Object.getOwnPropertyDescriptor(ctor.prototype, prop)!\n  const getter = desc.get!\n  Object.defineProperty(ctor.prototype, prop, {\n    get() {\n      const ret = getter.call(this)\n      Object.defineProperty(this, prop, { value: ret })\n      return ret\n    },\n  })\n}","/* eslint-disable no-underscore-dangle */\nimport {\n    Feature,\n    SimpleFeatureSerialized,\n  } from '@jbrowse/core/util/simpleFeature'\n\n  // import { getMismatches } from '../MismatchParser'\nimport { cacheGetter } from '../shared/util'\n\n  import { BamRecord } from '@gmod/bam'\n  \n  // locals\n  // import { getClip, getMismatches } from '../MismatchParser'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\n  import DashboardAdapter from './DashboardAdapter'\n  \n  export default class BamSlightlyLazyFeature implements Feature {\n    // uses parameter properties to automatically create fields on the class\n    // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n    constructor(\n      private record: BamRecord,\n      private adapter: DashboardAdapter,\n      private ref?: string,\n    ) {}\n  \n    id() {\n      return `${this.adapter.id}-${this.record.id}`\n    }\n    get mismatches() {\n      return MismatchParser.getMismatches(\n        this.record.CIGAR,\n        this.record.tags.MD as string | undefined,\n        this.record.seq,\n        this.ref,\n        this.record.qual,\n      )\n    }\n  \n    get qual() {\n      return this.record.qual?.join(' ')\n    }\n  \n    get(field: string): any {\n      return field === 'mismatches'\n        ? this.mismatches\n        : field === 'qual'\n          ? this.qual\n          : this.fields[field]\n    }\n  \n    parent() {\n      return undefined\n    }\n  \n    children() {\n      return undefined\n    }\n  \n    get fields(): SimpleFeatureSerialized {\n      const r = this.record\n      const a = this.adapter\n      const p = r.isPaired()\n      return {\n        start: r.start,\n        name: r.name,\n        end: r.end,\n        score: r.score,\n        strand: r.strand,\n        template_length: r.template_length,\n        flags: r.flags,\n        tags: r.tags,\n        refName: a.refIdToName(r.ref_id)!,\n        CIGAR: r.CIGAR,\n        seq: r.seq,\n        type: 'match',\n        pair_orientation: r.pair_orientation,\n        next_ref: p ? a.refIdToName(r.next_refid) : undefined,\n        next_pos: p ? r.next_pos : undefined,\n        next_segment_position: p\n          ? `${a.refIdToName(r.next_refid)}:${r.next_pos + 1}`\n          : undefined,\n        uniqueId: this.id(),\n      }\n    }\n  \n    toJSON(): SimpleFeatureSerialized {\n      return {\n        ...this.fields,\n        qual: this.qual,\n      }\n    }\n  }\n  \n  cacheGetter(BamSlightlyLazyFeature, 'fields')\n  cacheGetter(BamSlightlyLazyFeature, 'mismatches')","import { BamFile } from '@gmod/bam'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { bytesForRegions, updateStatus, Feature } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\n// locals\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature'\nimport { IFilter } from '../shared'\n\ninterface Header {\n  idToName: string[]\n  nameToId: Record<string, number>\n}\n\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n  private samHeader?: Header\n\n  private setupP?: Promise<Header>\n\n  // used for avoiding re-creation new BamSlightlyLazyFeatures, keeping\n  // mismatches in cache. at an average of 100kb-300kb, keeping even just 500\n  // of these in memory is memory intensive but can reduce recomputation on\n  // these objects\n  private ultraLongFeatureCache = new QuickLRU({\n    maxSize: 500,\n  })\n  \n  private configureP?: Promise<{\n    bam: BamFile\n    sequenceAdapter?: BaseFeatureDataAdapter\n  }>\n\n  // derived classes may not use the same configuration so a custom\n  // configure method allows derived classes to override this behavior\n  protected async configurePre() {\n    const bamLocation = this.getConf('bamLocation')\n    const location = this.getConf(['index', 'location'])\n    const indexType = this.getConf(['index', 'indexType'])\n    const pm = this.pluginManager\n    const csi = indexType === 'CSI'\n    const bam = new BamFile({\n      bamFilehandle: openLocation(bamLocation, pm),\n      csiFilehandle: csi ? openLocation(location, pm) : undefined,\n      baiFilehandle: !csi ? openLocation(location, pm) : undefined,\n\n      // chunkSizeLimit and fetchSizeLimit are more troublesome than\n      // helpful, and have given overly large values on the ultra long\n      // nanopore reads even with 500MB limits, so disabled with infinity\n      yieldThreadTime: Number.POSITIVE_INFINITY,\n    })\n\n    const adapterConfig = this.getConf('sequenceAdapter')\n    if (adapterConfig && this.getSubAdapter) {\n      const { dataAdapter } = await this.getSubAdapter(adapterConfig)\n      return {\n        bam,\n        sequenceAdapter: dataAdapter as BaseFeatureDataAdapter,\n      }\n    } else {\n      return { bam }\n    }\n  }\n\n  protected async configure() {\n    if (!this.configureP) {\n      this.configureP = this.configurePre().catch(e => {\n        this.configureP = undefined\n        throw e\n      })\n    }\n    return this.configureP\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    return bam.getHeaderText()\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const { bam } = await this.configure()\n    this.samHeader = await updateStatus(\n      'Downloading index',\n      statusCallback,\n      async () => {\n        const samHeader = await bam.getHeader()\n\n        // use the @SQ lines in the header to figure out the\n        // mapping between ref ref ID numbers and names\n        const idToName: string[] = []\n        const nameToId: Record<string, number> = {}\n        samHeader\n          ?.filter(l => l.tag === 'SQ')\n          .forEach((sqLine, refId) => {\n            const SN = sqLine.data.find(item => item.tag === 'SN')\n            if (SN) {\n              // this is the ref name\n              const refName = SN.value\n              nameToId[refName] = refId\n              idToName[refId] = refName\n            }\n          })\n\n        return { idToName, nameToId }\n      },\n    )\n    return this.samHeader\n  }\n\n  async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { idToName } = await this.setup(opts)\n    return idToName\n  }\n\n  private async seqFetch(refName: string, start: number, end: number) {\n    const { sequenceAdapter } = await this.configure()\n    const refSeqStore = sequenceAdapter\n    if (!refSeqStore) {\n      return undefined\n    }\n    if (!refName) {\n      return undefined\n    }\n\n    const features = refSeqStore.getFeatures({\n      refName,\n      start,\n      end,\n      assemblyName: '',\n    })\n\n    const seqChunks = await firstValueFrom(features.pipe(toArray()))\n\n    let sequence = ''\n    seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .forEach(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        sequence += chunkSeq.slice(trimStart, trimStart + trimLength)\n      })\n\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: IFilter\n    },\n  ) {\n\n    const MAX_FEATURES = 40000\n\n    const { refName, start, end, originalRefName } = region\n    const { stopToken, filterBy, statusCallback = () => {} } = opts || {}\n    \n    return ObservableCreate<Feature>(async observer => {\n\n      const { bam } = await this.configure()\n      await this.setup(opts)\n      checkStopToken(stopToken)\n      const records = await updateStatus(\n        'Downloading alignments',\n        statusCallback,\n        () => bam.getRecordsForRange(refName, start, end),\n      )\n      checkStopToken(stopToken)\n      await updateStatus('Processing alignments', statusCallback, async () => {\n\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n          filterReads\n        } = filterBy || {}\n\n        const stride = Math.ceil(records.length / MAX_FEATURES)\n\n        for (let i = 0; i < records.length; i += stride) {\n          if (stride > 1 && i % stride !== 0) continue // skip\n\n          const record = records[i]\n          let ref: string | undefined\n          let unseen_mutations = {}\n\n          if (!record.tags.MD) {\n            ref = await this.seqFetch(\n              originalRefName || refName,\n              record.start,\n              record.end,\n            )\n          }\n\n          const flags = record.flags\n          if ((flags & flagInclude) !== flagInclude && !(flags & flagExclude)) {\n            continue\n          }\n\n          if (tagFilter && tagFilter.tag) {\n            // const v = record.get(tagFilter.tag)\n            const v = record.tags[tagFilter.tag]\n\n            if (\n              !(tagFilter.value === '*'\n                ? v !== undefined\n                : `${v}`.split(',').includes(tagFilter.value)\n            )) {\n              continue\n            }\n          }\n\n          const um_filter =\n                tagFilter?.value && filterReads[tagFilter.value]\n                  ? filterReads[tagFilter.value].map((item) => item.unseenKey)\n                  : [];\n          \n\n          if(um_filter.length>0) {\n                        \n            var um = record.tags.UM ? record.tags.UM : ''\n            um = um.split(\",\")\n\n            \n            if (!um || !um.some(u => um_filter.includes(u))) {\n                continue\n            }\n          }\n\n          if (readName && record.get('name') !== readName) {\n            continue\n          }\n\n\n          const ret = this.ultraLongFeatureCache.get(`${record.id}`)\n          if (!ret) {\n            const elt = new BamSlightlyLazyFeature(record, this, ref)\n            this.ultraLongFeatureCache.set(`${record.id}`, elt)\n            observer.next(elt)\n          } else {\n            observer.next(ret)\n          }\n          // observer.next(new BamSlightlyLazyFeature(record, this, ref))\n        }\n        observer.complete()\n      })\n    })\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { bam } = await this.configure()\n    // this is a method to avoid calling on htsget adapters\n    if (bam.index) {\n      const bytes = await bytesForRegions(regions, bam)\n      const fetchSizeLimit = this.getConf('fetchSizeLimit')\n      return { bytes, fetchSizeLimit }\n    } else {\n      return super.getMultiRegionFeatureDensityStats(regions, opts)\n    }\n  }\n\n  freeResources(/* { region } */): void {}\n\n  // depends on setup being called before the BAM constructor\n  refIdToName(refId: number) {\n    return this.samHeader?.idToName[refId]\n  }\n}"],"names":["cacheGetter","ctor","prop","getter","ret","BamSlightlyLazyFeature","record","adapter","ref","MismatchParser.getMismatches","_a","field","r","a","p","BamAdapter","BaseFeatureDataAdapter","__publicField","QuickLRU","bamLocation","location","indexType","pm","csi","bam","BamFile","openLocation","adapterConfig","dataAdapter","opts","statusCallback","updateStatus","samHeader","idToName","nameToId","l","sqLine","refId","SN","item","refName","e","start","end","sequenceAdapter","refSeqStore","features","seqChunks","firstValueFrom","toArray","sequence","b","chunk","chunkStart","chunkEnd","trimStart","trimLength","chunkSeq","region","originalRefName","stopToken","filterBy","ObservableCreate","observer","checkStopToken","records","flagInclude","flagExclude","tagFilter","readName","filterReads","stride","i","flags","v","um_filter","um","u","elt","regions","bytes","bytesForRegions","fetchSizeLimit"],"mappings":"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"}