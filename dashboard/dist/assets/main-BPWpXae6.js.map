{"version":3,"file":"main-BPWpXae6.js","sources":["../../node_modules/@flatten-js/interval-tree/dist/main.mjs"],"sourcesContent":["/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than a pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */\nconst Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */\n    get max() {\n        return this.clone();   // this.high;\n    }\n\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            this.low === other_interval.low && this.high < other_interval.high;\n    }\n\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    equal_to(other_interval) {\n        return this.low === other_interval.low && this.high === other_interval.high;\n    }\n\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} other_interval - Other interval to merge with\n     * @returns {Interval}\n     */\n    merge(other_interval) {\n        return new Interval(\n            this.low === undefined ?\n                other_interval.low : (this.low < other_interval.low ? this.low : other_interval.low),\n            this.high === undefined ?\n                other_interval.high : (this.high > other_interval.high ? this.high : other_interval.high)\n        );\n    }\n\n    /**\n     * Returns how key should return\n     */\n    output() {\n        return [this.low, this.high];\n    }\n\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */\n    static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */\n    static comparable_less_than(val1, val2 ) {\n        return val1 < val2;\n    }\n};\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n\nclass Node {\n    constructor(key = undefined, value = undefined,\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;                     // reference to left child node\n        this.right = right;                   // reference to right child node\n        this.parent = parent;                 // reference to parent node\n        this.color = color;\n\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\n\n        /* If not, this should by an array of two numbers */\n        if (key && key instanceof Array && key.length === 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n                let [low, high] = key;\n                if (low > high) [low, high] = [high, low];\n                this.item.key = new Interval(low, high);\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil() {\n        return (this.item.key === undefined && this.item.value === undefined &&\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\n    }\n\n    _value_less_than(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.less_than ?\n            this.item.value.less_than(other_node.item.value) :\n            this.item.value < other_node.item.value;\n    }\n\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.less_than(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.less_than(other_node.item.key) ||\n                this.item.key.equal_to((other_node.item.key)) && this._value_less_than(other_node)\n        }\n    }\n\n    _value_equal(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.equal_to ?\n            this.item.value.equal_to(other_node.item.value) :\n            this.item.value === other_node.item.value;\n    }\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.equal_to(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\n        }\n    }\n\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.value = other_node.item.value;\n    }\n\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n\n// const nil_node = new Node();\n\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, () => count++);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(\n            node.item.key.output ? node.item.key.output() : node.item.key\n        ));\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push({\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\n            value: node.item.value\n        }));\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return (this.root == null || this.root === this.nil_node);\n    }\n\n    /**\n     * Clear tree\n     */\n    clear() {\n        this.root = null;\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */\n    insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        let search_node = new Node(key, value);\n        return !!this.tree_search(this.root, search_node);\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */\n    remove(key, value = key) {\n        let search_node = new Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) {\n            this.tree_delete(delete_node);\n        }\n        return delete_node;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let search_node = new Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        let search_node = new Node(interval);\n        return this.tree_find_any_interval(this.root, search_node);\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\n    }\n\n    /**\n     * Value Mapper. Walk through every node and map node value to another value\n     * @param callback(value,key) - function to be called for each tree item\n     */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n\n    /**\n     * @param {Interval} interval - optional if the iterator is intended to start from the beginning\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Iterator}\n     */\n    *iterate(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let node;\n        if (interval) {\n            node = this.tree_search_nearest_forward(this.root, new Node(interval));\n        } else if (this.root) {\n            node = this.local_minimum(this.root);\n        }\n        while (node) {\n            yield outputMapperFn(node.item.value, node.item.key);\n            node = this.tree_successor(node);\n        }\n    }\n\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n\n        if (this.root == null || this.root === this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node !== this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\n// Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n\n        current_node = insert_node;\n        while (current_node !== this.root && current_node.parent.color === RB_TREE_COLOR_RED) {\n            if (current_node.parent === current_node.parent.parent.left) {   // parent is left child of grandfather\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\n                if (uncle_node.color === RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {                                                    // Case 2 & 3. Uncle is black\n                    if (current_node === current_node.parent.right) {     // Case 2. Current if right child\n                        // This case is transformed into Case 3.\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\n                    // Re-color father and grandfather, rotate grandfather right\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {                                                         // parent is right child of grandfather\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\n                if (uncle_node.color === RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node === current_node.parent.left) {             // Case 5. Current is left child\n                        // Transform into case 6\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\n                    // Re-color father and grandfather, rotate grandfather left\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_delete(delete_node) {\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\n\n        if (delete_node.left === this.nil_node || delete_node.right === this.nil_node) {  // delete_node has less then 2 children\n            cut_node = delete_node;\n        }\n        else {                                                    // delete_node has 2 children\n            cut_node = this.tree_successor(delete_node);\n        }\n\n        // fix_node if single child of cut_node\n        if (cut_node.left !== this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/\n            fix_node.parent = cut_node.parent;\n        /*}*/\n\n        if (cut_node === this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node === cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();        // update max property of the parent\n        }\n\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\n\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node !== delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();           // update max property of the cut node at the new place\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\n        }\n\n        if (/*fix_node != this.nil_node && */cut_node.color === RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n\n        while (current_node !== this.root && current_node.parent != null && current_node.color === RB_TREE_COLOR_BLACK) {\n            if (current_node === current_node.parent.left) {          // fix node is left child\n                brother_node = current_node.parent.right;\n                if (brother_node.color === RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;                      // update brother\n                }\n                // Derive to cases 2..4: brother is black\n                if (brother_node.left.color === RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color === RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\n                    current_node = current_node.parent;                  // continue iteration\n                }\n                else {\n                    if (brother_node.right.color === RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;                     // update brother\n                        // Derive to case 4: left nephew black, right nephew red\n                    }\n                    // case 4: left nephew black, right nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;                         // exit from loop\n                }\n            }\n            else {                                             // fix node is right child\n                brother_node = current_node.parent.left;\n                if (brother_node.color === RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;                        // update brother\n                }\n                // Go to cases 2..4\n                if (brother_node.left.color === RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color === RB_TREE_COLOR_BLACK) {   // case 2\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\n                    current_node = current_node.parent;                              // continue iteration\n                }\n                else {\n                    if (brother_node.left.color === RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;                        // update brother\n                        // Derive to case 4: right nephew black, left nephew red\n                    }\n                    // case 4: right nephew black, left nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;                               // force exit from loop\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_search(node, search_node) {\n        if (node == null || node === this.nil_node)\n            return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    tree_search_nearest_forward(node, search_node) {\n        let best;\n        let curr = node;\n        while (curr && curr !== this.nil_node) {\n            if (curr.less_than(search_node)) {\n                if (curr.intersect(search_node)) {\n                    best = curr;\n                    curr = curr.left;\n                } else {\n                    curr = curr.right;\n                }\n            } else {\n                if (!best || curr.less_than(best)) best = curr;\n                curr = curr.left;\n            }\n        }\n        return best || null;\n    }\n\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node !== this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node !== this.nil_node) {\n            if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            if (!found && node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left !== this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right !== this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n\n        if (node.right !== this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right === current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n\n    rotate_left(x) {\n        let y = x.right;\n\n        x.right = y.left;           // b goes to x.right\n\n        if (y.left !== this.nil_node) {\n            y.left.parent = x;     // x becomes parent of b\n        }\n        y.parent = x.parent;       // move parent\n\n        if (x === this.root) {\n            this.root = y;           // y becomes root\n        }\n        else {                        // y becomes child of x.parent\n            if (x === x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;                 // x becomes left child of y\n        x.parent = y;               // and y becomes parent of x\n\n        if (x != null && x !== this.nil_node) {\n            x.update_max();\n        }\n\n        y = x.parent;\n        if (y != null && y !== this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    rotate_right(y) {\n        let x = y.left;\n\n        y.left = x.right;           // b goes to y.left\n\n        if (x.right !== this.nil_node) {\n            x.right.parent = y;        // y becomes parent of b\n        }\n        x.parent = y.parent;          // move parent\n\n        if (y === this.root) {        // x becomes root\n            this.root = x;\n        }\n        else {                        // y becomes child of x.parent\n            if (y === y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;                 // y becomes right child of x\n        y.parent = x;               // and x becomes parent of y\n\n        if (y !== null && y !== this.nil_node) {\n            y.update_max();\n        }\n\n        x = y.parent;\n        if (x != null && x !== this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    tree_walk(node, action) {\n        if (node != null && node !== this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /* Return true if all red nodes have exactly two black child nodes */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color === RB_TREE_COLOR_RED) {\n                if (!(node.left.color === RB_TREE_COLOR_BLACK && node.right.color === RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /* Throw error if not every path from root to bottom has same black height */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color === RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left !== this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right !== this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft !== heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    }\n}\n\nexport { Interval, Node, IntervalTree as default };\n"],"names":["Interval","low","high","other_interval","interval1","interval2","val1","val2","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","key","value","left","right","parent","color","other_node","comparable_max","search_node","comparable_less_than","IntervalTree","count","res","node","insert_node","delete_node","interval","outputMapperFn","resp_nodes","visitor","callback","tree","node_current","current_node","parent_node","uncle_node","cut_node","fix_node","brother_node","best","curr","found","node_min","node_max","node_successor","x","y","action","height","heightLeft","heightRight"],"mappings":"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","x_google_ignoreList":[0]}