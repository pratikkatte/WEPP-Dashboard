{"version":3,"file":"util-j5GANyWN.js","sources":["../../node_modules/@gmod/bed/esm/autoSql.js","../../node_modules/@gmod/bed/esm/as/autoSqlSchemas.js","../../node_modules/@gmod/bed/esm/defaultTypes.js","../../node_modules/@gmod/bed/esm/util.js","../../node_modules/@gmod/bed/esm/parser.js","../../node_modules/@jbrowse/plugin-bed/esm/generateBedMethylFeature.js","../../node_modules/@jbrowse/plugin-bed/esm/generateRepeatMaskerFeature.js","../../node_modules/@jbrowse/plugin-bed/esm/generateUcscTranscript.js","../../node_modules/@jbrowse/plugin-bed/esm/util.js"],"sourcesContent":["//@ts-nocheck\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n'use strict';\nfunction peg$subclass(child, parent) {\n    function ctor() {\n        this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n}\nfunction peg$SyntaxError(message, expected, found, location) {\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = 'SyntaxError';\n    if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(this, peg$SyntaxError);\n    }\n}\npeg$subclass(peg$SyntaxError, Error);\npeg$SyntaxError.buildMessage = function (expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n        literal: function (expectation) {\n            return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function (expectation) {\n            var escapedParts = '', i;\n            for (i = 0; i < expectation.parts.length; i++) {\n                escapedParts +=\n                    expectation.parts[i] instanceof Array\n                        ? classEscape(expectation.parts[i][0]) +\n                            '-' +\n                            classEscape(expectation.parts[i][1])\n                        : classEscape(expectation.parts[i]);\n            }\n            return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';\n        },\n        any: function (expectation) {\n            return 'any character';\n        },\n        end: function (expectation) {\n            return 'end of input';\n        },\n        other: function (expectation) {\n            return expectation.description;\n        },\n    };\n    function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n        return s\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/\"/g, '\\\\\"')\n            .replace(/\\0/g, '\\\\0')\n            .replace(/\\t/g, '\\\\t')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n        })\n            .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n        });\n    }\n    function classEscape(s) {\n        return s\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/\\]/g, '\\\\]')\n            .replace(/\\^/g, '\\\\^')\n            .replace(/-/g, '\\\\-')\n            .replace(/\\0/g, '\\\\0')\n            .replace(/\\t/g, '\\\\t')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n        })\n            .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n        });\n    }\n    function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected) {\n        var descriptions = new Array(expected.length), i, j;\n        for (i = 0; i < expected.length; i++) {\n            descriptions[i] = describeExpectation(expected[i]);\n        }\n        descriptions.sort();\n        if (descriptions.length > 0) {\n            for (i = 1, j = 1; i < descriptions.length; i++) {\n                if (descriptions[i - 1] !== descriptions[i]) {\n                    descriptions[j] = descriptions[i];\n                    j++;\n                }\n            }\n            descriptions.length = j;\n        }\n        switch (descriptions.length) {\n            case 1:\n                return descriptions[0];\n            case 2:\n                return descriptions[0] + ' or ' + descriptions[1];\n            default:\n                return (descriptions.slice(0, -1).join(', ') +\n                    ', or ' +\n                    descriptions[descriptions.length - 1]);\n        }\n    }\n    function describeFound(found) {\n        return found ? '\"' + literalEscape(found) + '\"' : 'end of input';\n    }\n    return ('Expected ' +\n        describeExpected(expected) +\n        ' but ' +\n        describeFound(found) +\n        ' found.');\n};\nfunction peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {}, peg$startRuleFunctions = { declaration: peg$parsedeclaration }, peg$startRuleFunction = peg$parsedeclaration, peg$c0 = '(', peg$c1 = peg$literalExpectation('(', false), peg$c2 = ')', peg$c3 = peg$literalExpectation(')', false), peg$c4 = function (type, name, comment, fields) {\n        return { type, name, comment, fields };\n    }, peg$c5 = 'simple', peg$c6 = peg$literalExpectation('simple', false), peg$c7 = 'object', peg$c8 = peg$literalExpectation('object', false), peg$c9 = 'table', peg$c10 = peg$literalExpectation('table', false), peg$c11 = 'auto', peg$c12 = peg$literalExpectation('auto', false), peg$c13 = 'primary', peg$c14 = peg$literalExpectation('primary', false), peg$c15 = 'index', peg$c16 = peg$literalExpectation('index', false), peg$c17 = 'unique', peg$c18 = peg$literalExpectation('unique', false), peg$c19 = function (f1, w) {\n        return w;\n    }, peg$c20 = function (f1, fds) {\n        if (f1.name) {\n            fds.unshift(f1);\n        }\n        return fds;\n    }, peg$c21 = '#', peg$c22 = peg$literalExpectation('#', false), peg$c23 = ';', peg$c24 = peg$literalExpectation(';', false), peg$c25 = function (type, name, comment) {\n        return { type, name, comment };\n    }, peg$c26 = '[', peg$c27 = peg$literalExpectation('[', false), peg$c28 = ']', peg$c29 = peg$literalExpectation(']', false), peg$c30 = function (type, size, name, comment) {\n        return { type, size, name, comment };\n    }, peg$c31 = function (type, vals, name, comment) {\n        return { type, vals, name, comment };\n    }, peg$c32 = ',', peg$c33 = peg$literalExpectation(',', false), peg$c34 = function (f1, fds) {\n        fds.unshift(f1);\n        return fds;\n    }, peg$c35 = 'int', peg$c36 = peg$literalExpectation('int', false), peg$c37 = 'uint', peg$c38 = peg$literalExpectation('uint', false), peg$c39 = 'short', peg$c40 = peg$literalExpectation('short', false), peg$c41 = 'ushort', peg$c42 = peg$literalExpectation('ushort', false), peg$c43 = 'byte', peg$c44 = peg$literalExpectation('byte', false), peg$c45 = 'ubyte', peg$c46 = peg$literalExpectation('ubyte', false), peg$c47 = 'float', peg$c48 = peg$literalExpectation('float', false), peg$c49 = 'char', peg$c50 = peg$literalExpectation('char', false), peg$c51 = 'string', peg$c52 = peg$literalExpectation('string', false), peg$c53 = 'lstring', peg$c54 = peg$literalExpectation('lstring', false), peg$c55 = 'enum', peg$c56 = peg$literalExpectation('enum', false), peg$c57 = 'double', peg$c58 = peg$literalExpectation('double', false), peg$c59 = 'bigint', peg$c60 = peg$literalExpectation('bigint', false), peg$c61 = 'set', peg$c62 = peg$literalExpectation('set', false), peg$c63 = function (t, n) {\n        return t + ' ' + n;\n    }, peg$c64 = /^[a-zA-Z_]/, peg$c65 = peg$classExpectation([['a', 'z'], ['A', 'Z'], '_'], false, false), peg$c66 = /^[a-zA-Z0-9_]/, peg$c67 = peg$classExpectation([['a', 'z'], ['A', 'Z'], ['0', '9'], '_'], false, false), peg$c68 = function (t) {\n        return text();\n    }, peg$c69 = '\"', peg$c70 = peg$literalExpectation('\"', false), peg$c71 = /^[^\"]/, peg$c72 = peg$classExpectation(['\"'], true, false), peg$c73 = function (t) {\n        return t.join('');\n    }, peg$c74 = /^[^\\n\\r]/, peg$c75 = peg$classExpectation(['\\n', '\\r'], true, false), peg$c76 = function (t) {\n        return t.join('').replace(/^\"/, '').replace(/\"$/, '');\n    }, peg$c77 = peg$otherExpectation('integer'), peg$c78 = /^[0-9]/, peg$c79 = peg$classExpectation([['0', '9']], false, false), peg$c80 = function () {\n        return parseInt(text(), 10);\n    }, peg$c81 = peg$otherExpectation('whitespace'), peg$c82 = /^[ \\t\\n\\r]/, peg$c83 = peg$classExpectation([' ', '\\t', '\\n', '\\r'], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;\n    if ('startRule' in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error('Can\\'t start parsing from rule \"' + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n    }\n    function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location) {\n        location =\n            location !== void 0\n                ? location\n                : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);\n    }\n    function error(message, location) {\n        location =\n            location !== void 0\n                ? location\n                : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location);\n    }\n    function peg$literalExpectation(text, ignoreCase) {\n        return { type: 'literal', text: text, ignoreCase: ignoreCase };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n        return {\n            type: 'class',\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase,\n        };\n    }\n    function peg$anyExpectation() {\n        return { type: 'any' };\n    }\n    function peg$endExpectation() {\n        return { type: 'end' };\n    }\n    function peg$otherExpectation(description) {\n        return { type: 'other', description: description };\n    }\n    function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos], p;\n        if (details) {\n            return details;\n        }\n        else {\n            p = pos - 1;\n            while (!peg$posDetailsCache[p]) {\n                p--;\n            }\n            details = peg$posDetailsCache[p];\n            details = {\n                line: details.line,\n                column: details.column,\n            };\n            while (p < pos) {\n                if (input.charCodeAt(p) === 10) {\n                    details.line++;\n                    details.column = 1;\n                }\n                else {\n                    details.column++;\n                }\n                p++;\n            }\n            peg$posDetailsCache[pos] = details;\n            return details;\n        }\n    }\n    function peg$computeLocation(startPos, endPos) {\n        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);\n        return {\n            start: {\n                offset: startPos,\n                line: startPosDetails.line,\n                column: startPosDetails.column,\n            },\n            end: {\n                offset: endPos,\n                line: endPosDetails.line,\n                column: endPosDetails.column,\n            },\n        };\n    }\n    function peg$fail(expected) {\n        if (peg$currPos < peg$maxFailPos) {\n            return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected);\n    }\n    function peg$buildSimpleError(message, location) {\n        return new peg$SyntaxError(message, null, null, location);\n    }\n    function peg$buildStructuredError(expected, found, location) {\n        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n    }\n    function peg$parsedeclaration() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parsedeclareType();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parsedeclareName();\n                    if (s4 !== peg$FAILED) {\n                        s5 = peg$parse_();\n                        if (s5 !== peg$FAILED) {\n                            s6 = peg$parsecomment();\n                            if (s6 !== peg$FAILED) {\n                                s7 = peg$parse_();\n                                if (s7 !== peg$FAILED) {\n                                    if (input.charCodeAt(peg$currPos) === 40) {\n                                        s8 = peg$c0;\n                                        peg$currPos++;\n                                    }\n                                    else {\n                                        s8 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                            peg$fail(peg$c1);\n                                        }\n                                    }\n                                    if (s8 !== peg$FAILED) {\n                                        s9 = peg$parse_();\n                                        if (s9 !== peg$FAILED) {\n                                            s10 = peg$parsefieldList();\n                                            if (s10 !== peg$FAILED) {\n                                                s11 = peg$parse_();\n                                                if (s11 !== peg$FAILED) {\n                                                    if (input.charCodeAt(peg$currPos) === 41) {\n                                                        s12 = peg$c2;\n                                                        peg$currPos++;\n                                                    }\n                                                    else {\n                                                        s12 = peg$FAILED;\n                                                        if (peg$silentFails === 0) {\n                                                            peg$fail(peg$c3);\n                                                        }\n                                                    }\n                                                    if (s12 !== peg$FAILED) {\n                                                        s13 = peg$parse_();\n                                                        if (s13 !== peg$FAILED) {\n                                                            peg$savedPos = s0;\n                                                            s1 = peg$c4(s2, s4, s6, s10);\n                                                            s0 = s1;\n                                                        }\n                                                        else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                        }\n                                                    }\n                                                    else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                    }\n                                                }\n                                                else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                }\n                                            }\n                                            else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                            }\n                                        }\n                                        else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                        }\n                                    }\n                                    else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                }\n                                else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsedeclareType() {\n        var s0;\n        if (input.substr(peg$currPos, 6) === peg$c5) {\n            s0 = peg$c5;\n            peg$currPos += 6;\n        }\n        else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c6);\n            }\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c7) {\n                s0 = peg$c7;\n                peg$currPos += 6;\n            }\n            else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c8);\n                }\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 5) === peg$c9) {\n                    s0 = peg$c9;\n                    peg$currPos += 5;\n                }\n                else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c10);\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parsedeclareName() {\n        var s0, s1, s2, s3;\n        s0 = peg$parsename();\n        if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsename();\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parseindexType();\n                if (s2 !== peg$FAILED) {\n                    s1 = [s1, s2];\n                    s0 = s1;\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsename();\n                if (s1 !== peg$FAILED) {\n                    if (input.substr(peg$currPos, 4) === peg$c11) {\n                        s2 = peg$c11;\n                        peg$currPos += 4;\n                    }\n                    else {\n                        s2 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c12);\n                        }\n                    }\n                    if (s2 !== peg$FAILED) {\n                        s1 = [s1, s2];\n                        s0 = s1;\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    s1 = peg$parsename();\n                    if (s1 !== peg$FAILED) {\n                        s2 = peg$parseindexType();\n                        if (s2 !== peg$FAILED) {\n                            if (input.substr(peg$currPos, 4) === peg$c11) {\n                                s3 = peg$c11;\n                                peg$currPos += 4;\n                            }\n                            else {\n                                s3 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                    peg$fail(peg$c12);\n                                }\n                            }\n                            if (s3 !== peg$FAILED) {\n                                s1 = [s1, s2, s3];\n                                s0 = s1;\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parseindexType() {\n        var s0;\n        if (input.substr(peg$currPos, 7) === peg$c13) {\n            s0 = peg$c13;\n            peg$currPos += 7;\n        }\n        else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c14);\n            }\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c15) {\n                s0 = peg$c15;\n                peg$currPos += 5;\n            }\n            else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c16);\n                }\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 6) === peg$c17) {\n                    s0 = peg$c17;\n                    peg$currPos += 6;\n                }\n                else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c18);\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parsecomment() {\n        var s0;\n        s0 = peg$parsenonQuotedString();\n        if (s0 === peg$FAILED) {\n            s0 = peg$parse_();\n        }\n        return s0;\n    }\n    function peg$parsefieldList() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$parsefield();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$currPos;\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                    s6 = peg$parsefield();\n                    if (s6 !== peg$FAILED) {\n                        peg$savedPos = s4;\n                        s5 = peg$c19(s1, s6);\n                        s4 = s5;\n                    }\n                    else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                }\n                while (s4 !== peg$FAILED) {\n                    s3.push(s4);\n                    s4 = peg$currPos;\n                    s5 = peg$parse_();\n                    if (s5 !== peg$FAILED) {\n                        s6 = peg$parsefield();\n                        if (s6 !== peg$FAILED) {\n                            peg$savedPos = s4;\n                            s5 = peg$c19(s1, s6);\n                            s4 = s5;\n                        }\n                        else {\n                            peg$currPos = s4;\n                            s4 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                    }\n                }\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c20(s1, s3);\n                        s0 = s1;\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsecommentStart() {\n        var s0;\n        if (input.charCodeAt(peg$currPos) === 35) {\n            s0 = peg$c21;\n            peg$currPos++;\n        }\n        else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c22);\n            }\n        }\n        return s0;\n    }\n    function peg$parseinternalComment() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parsecommentStart();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parsenonQuotedString();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        s1 = [s1, s2, s3, s4];\n                        s0 = s1;\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsefield() {\n        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n        s0 = peg$currPos;\n        s1 = peg$parsefieldType();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parsename();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 59) {\n                            s5 = peg$c23;\n                            peg$currPos++;\n                        }\n                        else {\n                            s5 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c24);\n                            }\n                        }\n                        if (s5 !== peg$FAILED) {\n                            s6 = peg$parse_();\n                            if (s6 !== peg$FAILED) {\n                                s7 = peg$parsecomment();\n                                if (s7 !== peg$FAILED) {\n                                    peg$savedPos = s0;\n                                    s1 = peg$c25(s1, s3, s7);\n                                    s0 = s1;\n                                }\n                                else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsefieldType();\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 91) {\n                        s3 = peg$c26;\n                        peg$currPos++;\n                    }\n                    else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c27);\n                        }\n                    }\n                    if (s3 !== peg$FAILED) {\n                        s4 = peg$parse_();\n                        if (s4 !== peg$FAILED) {\n                            s5 = peg$parsefieldSize();\n                            if (s5 !== peg$FAILED) {\n                                s6 = peg$parse_();\n                                if (s6 !== peg$FAILED) {\n                                    if (input.charCodeAt(peg$currPos) === 93) {\n                                        s7 = peg$c28;\n                                        peg$currPos++;\n                                    }\n                                    else {\n                                        s7 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                            peg$fail(peg$c29);\n                                        }\n                                    }\n                                    if (s7 !== peg$FAILED) {\n                                        s8 = peg$parse_();\n                                        if (s8 !== peg$FAILED) {\n                                            s9 = peg$parsename();\n                                            if (s9 !== peg$FAILED) {\n                                                s10 = peg$parse_();\n                                                if (s10 !== peg$FAILED) {\n                                                    if (input.charCodeAt(peg$currPos) === 59) {\n                                                        s11 = peg$c23;\n                                                        peg$currPos++;\n                                                    }\n                                                    else {\n                                                        s11 = peg$FAILED;\n                                                        if (peg$silentFails === 0) {\n                                                            peg$fail(peg$c24);\n                                                        }\n                                                    }\n                                                    if (s11 !== peg$FAILED) {\n                                                        s12 = peg$parse_();\n                                                        if (s12 !== peg$FAILED) {\n                                                            s13 = peg$parsecomment();\n                                                            if (s13 !== peg$FAILED) {\n                                                                peg$savedPos = s0;\n                                                                s1 = peg$c30(s1, s5, s9, s13);\n                                                                s0 = s1;\n                                                            }\n                                                            else {\n                                                                peg$currPos = s0;\n                                                                s0 = peg$FAILED;\n                                                            }\n                                                        }\n                                                        else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                        }\n                                                    }\n                                                    else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                    }\n                                                }\n                                                else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                }\n                                            }\n                                            else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                            }\n                                        }\n                                        else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                        }\n                                    }\n                                    else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                }\n                                else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsefieldType();\n                if (s1 !== peg$FAILED) {\n                    s2 = peg$parse_();\n                    if (s2 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 40) {\n                            s3 = peg$c0;\n                            peg$currPos++;\n                        }\n                        else {\n                            s3 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c1);\n                            }\n                        }\n                        if (s3 !== peg$FAILED) {\n                            s4 = peg$parse_();\n                            if (s4 !== peg$FAILED) {\n                                s5 = peg$parsefieldValues();\n                                if (s5 !== peg$FAILED) {\n                                    s6 = peg$parse_();\n                                    if (s6 !== peg$FAILED) {\n                                        if (input.charCodeAt(peg$currPos) === 41) {\n                                            s7 = peg$c2;\n                                            peg$currPos++;\n                                        }\n                                        else {\n                                            s7 = peg$FAILED;\n                                            if (peg$silentFails === 0) {\n                                                peg$fail(peg$c3);\n                                            }\n                                        }\n                                        if (s7 !== peg$FAILED) {\n                                            s8 = peg$parse_();\n                                            if (s8 !== peg$FAILED) {\n                                                s9 = peg$parsename();\n                                                if (s9 !== peg$FAILED) {\n                                                    s10 = peg$parse_();\n                                                    if (s10 !== peg$FAILED) {\n                                                        if (input.charCodeAt(peg$currPos) === 59) {\n                                                            s11 = peg$c23;\n                                                            peg$currPos++;\n                                                        }\n                                                        else {\n                                                            s11 = peg$FAILED;\n                                                            if (peg$silentFails === 0) {\n                                                                peg$fail(peg$c24);\n                                                            }\n                                                        }\n                                                        if (s11 !== peg$FAILED) {\n                                                            s12 = peg$parse_();\n                                                            if (s12 !== peg$FAILED) {\n                                                                s13 = peg$parsecomment();\n                                                                if (s13 !== peg$FAILED) {\n                                                                    peg$savedPos = s0;\n                                                                    s1 = peg$c31(s1, s5, s9, s13);\n                                                                    s0 = s1;\n                                                                }\n                                                                else {\n                                                                    peg$currPos = s0;\n                                                                    s0 = peg$FAILED;\n                                                                }\n                                                            }\n                                                            else {\n                                                                peg$currPos = s0;\n                                                                s0 = peg$FAILED;\n                                                            }\n                                                        }\n                                                        else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                        }\n                                                    }\n                                                    else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                    }\n                                                }\n                                                else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                }\n                                            }\n                                            else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                            }\n                                        }\n                                        else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                        }\n                                    }\n                                    else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                }\n                                else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            }\n                            else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        }\n                        else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                    s0 = peg$parseinternalComment();\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parsefieldValues() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$parsename();\n        if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 44) {\n                s4 = peg$c32;\n                peg$currPos++;\n            }\n            else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c33);\n                }\n            }\n            if (s4 !== peg$FAILED) {\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                    s6 = peg$parsename();\n                    if (s6 !== peg$FAILED) {\n                        peg$savedPos = s3;\n                        s4 = peg$c19(s1, s6);\n                        s3 = s4;\n                    }\n                    else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n            }\n            while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                    s4 = peg$c32;\n                    peg$currPos++;\n                }\n                else {\n                    s4 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c33);\n                    }\n                }\n                if (s4 !== peg$FAILED) {\n                    s5 = peg$parse_();\n                    if (s5 !== peg$FAILED) {\n                        s6 = peg$parsename();\n                        if (s6 !== peg$FAILED) {\n                            peg$savedPos = s3;\n                            s4 = peg$c19(s1, s6);\n                            s3 = s4;\n                        }\n                        else {\n                            peg$currPos = s3;\n                            s3 = peg$FAILED;\n                        }\n                    }\n                    else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                    }\n                }\n                else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                }\n            }\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c34(s1, s2);\n                s0 = s1;\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsefieldType() {\n        var s0, s1, s2, s3;\n        if (input.substr(peg$currPos, 3) === peg$c35) {\n            s0 = peg$c35;\n            peg$currPos += 3;\n        }\n        else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c36);\n            }\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 4) === peg$c37) {\n                s0 = peg$c37;\n                peg$currPos += 4;\n            }\n            else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c38);\n                }\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 5) === peg$c39) {\n                    s0 = peg$c39;\n                    peg$currPos += 5;\n                }\n                else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c40);\n                    }\n                }\n                if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 6) === peg$c41) {\n                        s0 = peg$c41;\n                        peg$currPos += 6;\n                    }\n                    else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c42);\n                        }\n                    }\n                    if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 4) === peg$c43) {\n                            s0 = peg$c43;\n                            peg$currPos += 4;\n                        }\n                        else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c44);\n                            }\n                        }\n                        if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 5) === peg$c45) {\n                                s0 = peg$c45;\n                                peg$currPos += 5;\n                            }\n                            else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                    peg$fail(peg$c46);\n                                }\n                            }\n                            if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 5) === peg$c47) {\n                                    s0 = peg$c47;\n                                    peg$currPos += 5;\n                                }\n                                else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) {\n                                        peg$fail(peg$c48);\n                                    }\n                                }\n                                if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 4) === peg$c49) {\n                                        s0 = peg$c49;\n                                        peg$currPos += 4;\n                                    }\n                                    else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                            peg$fail(peg$c50);\n                                        }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 6) === peg$c51) {\n                                            s0 = peg$c51;\n                                            peg$currPos += 6;\n                                        }\n                                        else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) {\n                                                peg$fail(peg$c52);\n                                            }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 7) === peg$c53) {\n                                                s0 = peg$c53;\n                                                peg$currPos += 7;\n                                            }\n                                            else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) {\n                                                    peg$fail(peg$c54);\n                                                }\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                                if (input.substr(peg$currPos, 4) === peg$c55) {\n                                                    s0 = peg$c55;\n                                                    peg$currPos += 4;\n                                                }\n                                                else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) {\n                                                        peg$fail(peg$c56);\n                                                    }\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                    if (input.substr(peg$currPos, 6) === peg$c57) {\n                                                        s0 = peg$c57;\n                                                        peg$currPos += 6;\n                                                    }\n                                                    else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) {\n                                                            peg$fail(peg$c58);\n                                                        }\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                        if (input.substr(peg$currPos, 6) === peg$c59) {\n                                                            s0 = peg$c59;\n                                                            peg$currPos += 6;\n                                                        }\n                                                        else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) {\n                                                                peg$fail(peg$c60);\n                                                            }\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                            if (input.substr(peg$currPos, 3) === peg$c61) {\n                                                                s0 = peg$c61;\n                                                                peg$currPos += 3;\n                                                            }\n                                                            else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) {\n                                                                    peg$fail(peg$c62);\n                                                                }\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                                s0 = peg$currPos;\n                                                                s1 = peg$parsedeclareType();\n                                                                if (s1 !== peg$FAILED) {\n                                                                    s2 = peg$parse_();\n                                                                    if (s2 !== peg$FAILED) {\n                                                                        s3 = peg$parsedeclareName();\n                                                                        if (s3 !== peg$FAILED) {\n                                                                            peg$savedPos = s0;\n                                                                            s1 = peg$c63(s1, s3);\n                                                                            s0 = s1;\n                                                                        }\n                                                                        else {\n                                                                            peg$currPos = s0;\n                                                                            s0 = peg$FAILED;\n                                                                        }\n                                                                    }\n                                                                    else {\n                                                                        peg$currPos = s0;\n                                                                        s0 = peg$FAILED;\n                                                                    }\n                                                                }\n                                                                else {\n                                                                    peg$currPos = s0;\n                                                                    s0 = peg$FAILED;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parsefieldSize() {\n        var s0;\n        s0 = peg$parsenumber();\n        if (s0 === peg$FAILED) {\n            s0 = peg$parsename();\n        }\n        return s0;\n    }\n    function peg$parsename() {\n        var s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        if (peg$c64.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n        }\n        else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c65);\n            }\n        }\n        if (s2 !== peg$FAILED) {\n            s3 = [];\n            if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c67);\n                }\n            }\n            while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                if (peg$c66.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                }\n                else {\n                    s4 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c67);\n                    }\n                }\n            }\n            if (s3 !== peg$FAILED) {\n                s2 = [s2, s3];\n                s1 = s2;\n            }\n            else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c68(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parsequotedString() {\n        var s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c69;\n            peg$currPos++;\n        }\n        else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c70);\n            }\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = [];\n            if (peg$c71.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c72);\n                }\n            }\n            while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                if (peg$c71.test(input.charAt(peg$currPos))) {\n                    s3 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                }\n                else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c72);\n                    }\n                }\n            }\n            if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 34) {\n                    s3 = peg$c69;\n                    peg$currPos++;\n                }\n                else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c70);\n                    }\n                }\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c73(s2);\n                    s0 = s1;\n                }\n                else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parsenonQuotedString() {\n        var s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$c74.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n        }\n        else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c75);\n            }\n        }\n        while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$c74.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c75);\n                }\n            }\n        }\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c76(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parsenumber() {\n        var s0, s1, s2, s3;\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n            s2 = [];\n            if (peg$c78.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c79);\n                }\n            }\n            if (s3 !== peg$FAILED) {\n                while (s3 !== peg$FAILED) {\n                    s2.push(s3);\n                    if (peg$c78.test(input.charAt(peg$currPos))) {\n                        s3 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                    }\n                    else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c79);\n                        }\n                    }\n                }\n            }\n            else {\n                s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c80();\n                s0 = s1;\n            }\n            else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c77);\n            }\n        }\n        return s0;\n    }\n    function peg$parse_() {\n        var s0, s1;\n        peg$silentFails++;\n        s0 = [];\n        if (peg$c82.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        }\n        else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c83);\n            }\n        }\n        while (s1 !== peg$FAILED) {\n            s0.push(s1);\n            if (peg$c82.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            }\n            else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c83);\n                }\n            }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n                peg$fail(peg$c81);\n            }\n        }\n        return s0;\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n    }\n    else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length\n            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n}\nexport default {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse,\n};\n//# sourceMappingURL=autoSql.js.map","export const bigChain = `table bigChain\n\"bigChain pairwise alignment\"\n    (\n    string chrom;       \"Reference sequence chromosome or scaffold\"\n    uint   chromStart;  \"Start position in chromosome\"\n    uint   chromEnd;    \"End position in chromosome\"\n    string name;        \"Name or ID of item, ideally both human readable and unique\"\n    uint score;         \"Score (0-1000)\"\n    char[1] strand;     \"+ or - for strand\"\n    uint tSize;         \"size of target sequence\"\n    string qName;       \"name of query sequence\"\n    uint qSize;         \"size of query sequence\"\n    uint qStart;        \"start of alignment on query sequence\"\n    uint qEnd;          \"end of alignment on query sequence\"\n    uint chainScore;    \"score from chain\"\n    )`;\nexport const bigGenePred = `table bigGenePred\n\"bigGenePred gene models\"\n   (\n   string chrom;       \"Reference sequence chromosome or scaffold\"\n   uint   chromStart;  \"Start position in chromosome\"\n   uint   chromEnd;    \"End position in chromosome\"\n   string name;        \"Name or ID of item, ideally both human readable and unique\"\n   uint score;         \"Score (0-1000)\"\n   char[1] strand;     \"+ or - for strand\"\n   uint thickStart;    \"Start of where display should be thick (start codon)\"\n   uint thickEnd;      \"End of where display should be thick (stop codon)\"\n   uint reserved;       \"RGB value (use R,G,B string in input file)\"\n   int blockCount;     \"Number of blocks\"\n   int[blockCount] blockSizes; \"Comma separated list of block sizes\"\n   int[blockCount] chromStarts; \"Start positions relative to chromStart\"\n   string name2;       \"Alternative/human readable name\"\n   string cdsStartStat; \"Status of CDS start annotation (none, unknown, incomplete, or complete)\"\n   string cdsEndStat;   \"Status of CDS end annotation (none, unknown, incomplete, or complete)\"\n   int[blockCount] exonFrames; \"Exon frame {0,1,2}, or -1 if no frame for exon\"\n   string type;        \"Transcript type\"\n   string geneName;    \"Primary identifier for gene\"\n   string geneName2;   \"Alternative/human readable gene name\"\n   string geneType;    \"Gene type\"\n   )`;\nexport const bigInteract = `table interact\n\"interaction between two regions\"\n    (\n    string chrom;        \"Chromosome (or contig, scaffold, etc.). For interchromosomal, use 2 records\"\n    uint chromStart;     \"Start position of lower region. For interchromosomal, set to chromStart of this region\"\n    uint chromEnd;       \"End position of upper region. For interchromosomal, set to chromEnd of this region\"\n    string name;         \"Name of item, for display.  Usually 'sourceName/targetName/exp' or empty\"\n    uint score;          \"Score (0-1000)\"\n    double value;        \"Strength of interaction or other data value. Typically basis for score\"\n    string exp;          \"Experiment name (metadata for filtering). Use . if not applicable\"\n    string color;        \"Item color.  Specified as r,g,b or hexadecimal #RRGGBB or html color name, as in //www.w3.org/TR/css3-color/#html4. Use 0 and spectrum setting to shade by score\"\n    string sourceChrom;  \"Chromosome of source region (directional) or lower region. For non-directional interchromosomal, chrom of this region.\"\n    uint sourceStart;    \"Start position in chromosome of source/lower/this region\"\n    uint sourceEnd;      \"End position in chromosome of source/lower/this region\"\n    string sourceName;   \"Identifier of source/lower/this region\"\n    string sourceStrand; \"Orientation of source/lower/this region: + or -.  Use . if not applicable\"\n    string targetChrom;  \"Chromosome of target region (directional) or upper region. For non-directional interchromosomal, chrom of other region\"\n    uint targetStart;    \"Start position in chromosome of target/upper/this region\"\n    uint targetEnd;      \"End position in chromosome of target/upper/this region\"\n    string targetName;   \"Identifier of target/upper/this region\"\n    string targetStrand; \"Orientation of target/upper/this region: + or -.  Use . if not applicable\"\n\n    )`;\nexport const bigLink = `table bigLink\n\"bigLink pairwise alignment\"\n    (\n    string chrom;       \"Reference sequence chromosome or scaffold\"\n    uint   chromStart;  \"Start position in chromosome\"\n    uint   chromEnd;    \"End position in chromosome\"\n    string name;        \"Name or ID of item, ideally both human readable and unique\"\n    uint qStart;        \"start of alignment on query sequence\"\n    )`;\nexport const bigMaf = `table bedMaf\n\"Bed3 with MAF block\"\n    (\n    string chrom;      \"Reference sequence chromosome or scaffold\"\n    uint   chromStart; \"Start position in chromosome\"\n    uint   chromEnd;   \"End position in chromosome\"\n    lstring mafBlock;   \"MAF block\"\n    )`;\nexport const bigNarrowPeak = `table bigNarrowPeak\n\"BED6+4 Peaks of signal enrichment based on pooled, normalized (interpreted) data.\"\n(\n    string chrom;        \"Reference sequence chromosome or scaffold\"\n    uint   chromStart;   \"Start position in chromosome\"\n    uint   chromEnd;     \"End position in chromosome\"\n    string name;\t \"Name given to a region (preferably unique). Use . if no name is assigned\"\n    uint   score;        \"Indicates how dark the peak will be displayed in the browser (0-1000) \"\n    char[1]  strand;     \"+ or - or . for unknown\"\n    float  signalValue;  \"Measurement of average enrichment for the region\"\n    float  pValue;       \"Statistical significance of signal value (-log10). Set to -1 if not used.\"\n    float  qValue;       \"Statistical significance with multiple-test correction applied (FDR -log10). Set to -1 if not used.\"\n    int   peak;         \"Point-source called for this peak; 0-based offset from chromStart. Set to -1 if no point-source called.\"\n)`;\nexport const bigPsl = `table bigPsl\n\"bigPsl pairwise alignment\"\n    (\n    string chrom;       \"Reference sequence chromosome or scaffold\"\n    uint   chromStart;  \"Start position in chromosome\"\n    uint   chromEnd;    \"End position in chromosome\"\n    string name;        \"Name or ID of item, ideally both human readable and unique\"\n    uint score;         \"Score (0-1000)\"\n    char[1] strand;     \"+ or - indicates whether the query aligns to the + or - strand on the reference\"\n    uint thickStart;    \"Start of where display should be thick (start codon)\"\n    uint thickEnd;      \"End of where display should be thick (stop codon)\"\n    uint reserved;       \"RGB value (use R,G,B string in input file)\"\n    int blockCount;     \"Number of blocks\"\n    int[blockCount] blockSizes; \"Comma separated list of block sizes\"\n    int[blockCount] chromStarts; \"Start positions relative to chromStart\"\n\n    uint    oChromStart;\"Start position in other chromosome\"\n    uint    oChromEnd;  \"End position in other chromosome\"\n    char[1] oStrand;    \"+ or -, - means that psl was reversed into BED-compatible coordinates\"\n    uint    oChromSize; \"Size of other chromosome.\"\n    int[blockCount] oChromStarts; \"Start positions relative to oChromStart or from oChromStart+oChromSize depending on strand\"\n\n    lstring  oSequence;  \"Sequence on other chrom (or empty)\"\n    string   oCDS;       \"CDS in NCBI format\"\n\n    uint    chromSize;\"Size of target chromosome\"\n\n    uint match;        \"Number of bases matched.\"\n    uint misMatch; \" Number of bases that don't match \"\n    uint repMatch; \" Number of bases that match but are part of repeats \"\n    uint nCount;   \" Number of 'N' bases \"\n    uint seqType;    \"0=empty, 1=nucleotide, 2=amino_acid\"\n    )`;\nexport const defaultBedSchema = `table defaultBedSchema\n\"BED12\"\n    (\n    string chrom;      \"The name of the chromosome (e.g. chr3, chrY, chr2_random) or scaffold (e.g. scaffold10671).\"\n    uint   chromStart; \"The starting position of the feature in the chromosome or scaffold. The first base in a chromosome is numbered 0.\"\n    uint   chromEnd;   \"The ending position of the feature in the chromosome or scaffold. The chromEnd base is not included in the display of the feature. For example, the first 100 bases of a chromosome are defined as chromStart=0, chromEnd=100, and span the bases numbered 0-99.\"\n    string   name;   \"Defines the name of the BED line.\"\n    float   score;   \"Feature score, doesn't care about the 0-1000 limit as in bed\"\n    char   strand;   \"Defines the strand. Either '.' (=no strand) or '+' or '-'\"\n    uint thickStart; \"The starting position at which the feature is drawn thickly (for example, the start codon in gene displays). When there is no thick part, thickStart and thickEnd are usually set to the chromStart position.\"\n    uint thickEnd; \"The ending position at which the feature is drawn thickly (for example the stop codon in gene displays).\"\n    string itemRgb; \"An RGB value of the form R,G,B (e.g. 255,0,0). \"\n    uint blockCount; \" The number of blocks (exons) in the BED line.\"\n    uint[blockCount] blockSizes; \" A comma-separated list of the block sizes. The number of items in this list should correspond to blockCount.\"\n    uint[blockCount] blockStarts; \"A comma-separated list of block starts. All of the blockStart positions should be calculated relative to chromStart. The number of items in this list should correspond to blockCount.\"\n    )`;\nexport const mafFrames = `table mafFrames\n\"codon frame assignment for MAF components\"\n    (\n    string chrom;      \"Reference sequence chromosome or scaffold\"\n    uint   chromStart; \"Start range in chromosome\"\n    uint   chromEnd;   \"End range in chromosome\"\n    string src;        \"Name of sequence source in MAF\"\n    ubyte frame;       \"frame (0,1,2) for first base(+) or last bast(-)\"\n    char[1] strand;    \"+ or -\"\n    string name;       \"Name of gene used to define frame\"\n    int    prevFramePos;  \"target position of the previous base (in transcription direction) that continues this frame, or -1 if none, or frame not contiguous\"\n    int    nextFramePos;  \"target position of the next base (in transcription direction) that continues this frame, or -1 if none, or frame not contiguous\"\n    ubyte  isExonStart;  \"does this start the CDS portion of an exon?\"\n    ubyte  isExonEnd;    \"does this end the CDS portion of an exon?\"\n    )`;\nexport const mafSummary = `table mafSummary\n\"Positions and scores for alignment blocks\"\n    (\n    string chrom;      \"Reference sequence chromosome or scaffold\"\n    uint   chromStart; \"Start position in chromosome\"\n    uint   chromEnd;   \"End position in chromosome\"\n    string src;        \"Sequence name or database of alignment\"\n    float  score;      \"Floating point score.\"\n    char[1] leftStatus;  \"Gap/break annotation for preceding block\"\n    char[1] rightStatus; \"Gap/break annotation for following block\"\n    )`;\n//# sourceMappingURL=autoSqlSchemas.js.map","import parser from \"./autoSql.js\";\nimport * as types from \"./as/autoSqlSchemas.js\";\nexport default Object.fromEntries(Object.entries(types).map(([key, value]) => [\n    key,\n    // @ts-expect-error\n    parser.parse(value.trim()),\n]));\n//# sourceMappingURL=defaultTypes.js.map","/*\n * adds some type annotations to the autoSql schema for numeric fields ['uint',\n * 'int', 'float', 'long'] \"isNumeric\" is added for array types \"isArray\" is\n * added for numeric array types \"isArray\" and \"arrayIsNumeric\" is set\n *\n * @param autoSql - an autoSql schema from the peg parser\n * @return autoSql with type annotations added\n */\nexport function detectTypes(autoSql) {\n    const numericTypes = new Set(['uint', 'int', 'float', 'long']);\n    return {\n        ...autoSql,\n        fields: autoSql.fields\n            .map(autoField => ({\n            ...autoField,\n            isArray: autoField.size && autoField.type !== 'char',\n            arrayIsNumeric: autoField.size && numericTypes.has(autoField.type),\n            isNumeric: !autoField.size && numericTypes.has(autoField.type),\n        }))\n            // this is needed because the autoSql doesn't properly parse comments in the autoSql\n            .filter(f => !!f.name),\n    };\n}\n//# sourceMappingURL=util.js.map","import parser from \"./autoSql.js\";\nimport types from \"./defaultTypes.js\";\nimport { detectTypes } from \"./util.js\";\nconst strandMap = { '.': 0, '-': -1, '+': 1 };\n// heuristic that a BED file is BED12 like...the number in col 10 is\n// blockCount-like\nfunction isBed12Like(fields) {\n    return (fields.length >= 12 &&\n        !Number.isNaN(Number.parseInt(fields[9], 10)) &&\n        fields[10]?.split(',').filter(f => !!f).length ===\n            Number.parseInt(fields[9], 10));\n}\nexport default class BED {\n    constructor(arguments_ = {}) {\n        if (arguments_.autoSql) {\n            this.autoSql = detectTypes(\n            // @ts-expect-error\n            parser.parse(arguments_.autoSql));\n        }\n        else if (arguments_.type) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!types[arguments_.type]) {\n                throw new Error('Type not found');\n            }\n            this.autoSql = detectTypes(types[arguments_.type]);\n        }\n        else {\n            this.autoSql = detectTypes(types.defaultBedSchema);\n            this.attemptDefaultBed = true;\n        }\n    }\n    /*\n     * parses a line of text as a BED line with the loaded autoSql schema\n     *\n     * @param line - a BED line as tab delimited text or array\n     * @param opts - supply opts.uniqueId\n     * @return a object representing a feature\n     */\n    parseLine(line, options = {}) {\n        const { autoSql } = this;\n        const { uniqueId } = options;\n        const fields = Array.isArray(line) ? line : line.split('\\t');\n        let feature = {};\n        if (!this.attemptDefaultBed ||\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            (this.attemptDefaultBed && isBed12Like(fields))) {\n            for (let index = 0; index < autoSql.fields.length; index++) {\n                const autoField = autoSql.fields[index];\n                let columnValue = fields[index];\n                const { isNumeric, isArray, arrayIsNumeric, name } = autoField;\n                if (columnValue === null || columnValue === undefined) {\n                    break;\n                }\n                if (columnValue !== '.') {\n                    if (isNumeric) {\n                        const number_ = Number(columnValue);\n                        columnValue = Number.isNaN(number_) ? columnValue : number_;\n                    }\n                    else if (isArray) {\n                        columnValue = columnValue.split(',');\n                        if (columnValue.at(-1) === '') {\n                            columnValue.pop();\n                        }\n                        if (arrayIsNumeric) {\n                            columnValue = columnValue.map(Number);\n                        }\n                    }\n                    feature[name] = columnValue;\n                }\n            }\n        }\n        else {\n            const fieldNames = ['chrom', 'chromStart', 'chromEnd', 'name'];\n            feature = Object.fromEntries(fields.map((f, index) => [fieldNames[index] || 'field' + index, f]));\n            feature.chromStart = +feature.chromStart;\n            feature.chromEnd = +feature.chromEnd;\n            if (!Number.isNaN(Number.parseFloat(feature.field4))) {\n                feature.score = +feature.field4;\n                delete feature.field4;\n            }\n            if (feature.field5 === '+' || feature.field5 === '-') {\n                feature.strand = feature.field5;\n                delete feature.field5;\n            }\n        }\n        if (uniqueId) {\n            feature.uniqueId = uniqueId;\n        }\n        feature.strand = strandMap[feature.strand] || 0;\n        feature.chrom = decodeURIComponent(feature.chrom);\n        return feature;\n    }\n}\n//# sourceMappingURL=parser.js.map","export function isBedMethylFeature({ splitLine, start, end, }) {\n    return +(splitLine[6] || 0) === start && +(splitLine[7] || 0) === end;\n}\nexport function generateBedMethylFeature({ splitLine, uniqueId, refName, start, end, }) {\n    const [, , , code, , strand, , , color, n_valid_cov, fraction_modified, n_mod, n_canonical, n_other_mod, n_delete, n_fail, n_diff, n_nocall,] = splitLine;\n    return {\n        uniqueId,\n        refName,\n        start,\n        end,\n        code,\n        score: +fraction_modified || 0,\n        strand,\n        color,\n        source: code,\n        n_valid_cov,\n        fraction_modified,\n        n_mod,\n        n_canonical,\n        n_other_mod,\n        n_delete,\n        n_fail,\n        n_diff,\n        n_nocall,\n    };\n}\n","export function isRepeatMaskerDescriptionField(desc) {\n    const ret = desc === null || desc === void 0 ? void 0 : desc.trim().split(' ');\n    return [0, 1, 2, 3, 5, 6].every(s => (ret === null || ret === void 0 ? void 0 : ret[s]) !== undefined ? !Number.isNaN(+ret[s]) : false);\n}\nfunction makeRepeatTrackDescription(description) {\n    if (isRepeatMaskerDescriptionField(description)) {\n        const [bitsw_score, percent_div, percent_del, percent_ins, query_chr, query_begin, query_end, query_remaining, orientation, matching_repeat_name, matching_repeat_class, matching_repeat_begin, matching_repeat_end, matching_repeat_remaining, repeat_id,] = description.trim().split(' ');\n        return {\n            bitsw_score,\n            percent_div,\n            percent_del,\n            percent_ins,\n            query_chr,\n            query_begin,\n            query_end,\n            query_remaining,\n            orientation,\n            matching_repeat_name,\n            matching_repeat_class,\n            matching_repeat_begin,\n            matching_repeat_end,\n            matching_repeat_remaining,\n            repeat_id,\n        };\n    }\n    return { description };\n}\nexport function generateRepeatMaskerFeature({ uniqueId, refName, start, end, description, ...rest }) {\n    return {\n        ...rest,\n        ...makeRepeatTrackDescription(description),\n        uniqueId,\n        refName,\n        start,\n        end,\n    };\n}\n","export function isUcscTranscript({ thickStart, blockCount, strand, }) {\n    return thickStart && blockCount && strand !== 0;\n}\nexport function generateUcscTranscript(data) {\n    const { strand = 0, chrom: _1, chromStart: _2, chromEnd: _3, chromStarts, blockStarts, blockSizes, uniqueId, ...rest } = data;\n    const { subfeatures: oldSubfeatures, thickStart, thickEnd, blockCount, refName, ...rest2 } = rest;\n    const subfeatures = [];\n    const feats = oldSubfeatures\n        .filter(child => child.type === 'block')\n        .sort((a, b) => a.start - b.start);\n    for (const block of feats) {\n        const start = block.start;\n        const end = block.end;\n        if (thickStart >= end) {\n            subfeatures.push({\n                type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n                start,\n                end,\n                refName,\n            });\n        }\n        else if (thickStart > start && thickStart < end && thickEnd >= end) {\n            subfeatures.push({\n                type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n                start,\n                end: thickStart,\n                refName,\n            }, {\n                type: 'CDS',\n                start: thickStart,\n                end,\n                refName,\n            });\n        }\n        else if (thickStart <= start && thickEnd >= end) {\n            subfeatures.push({\n                type: 'CDS',\n                start,\n                end,\n                refName,\n            });\n        }\n        else if (thickStart > start && thickStart < end && thickEnd < end) {\n            subfeatures.push({\n                type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n                start,\n                end: thickStart,\n                refName,\n            }, {\n                type: 'CDS',\n                start: thickStart,\n                end: thickEnd,\n                refName,\n            }, {\n                type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n                start: thickEnd,\n                end,\n                refName,\n            });\n        }\n        else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n            subfeatures.push({\n                type: 'CDS',\n                start,\n                end: thickEnd,\n                refName,\n            }, {\n                type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n                start: thickEnd,\n                end,\n                refName,\n            });\n        }\n        else if (thickEnd <= start) {\n            subfeatures.push({\n                type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n                start,\n                end,\n                refName,\n            });\n        }\n    }\n    return {\n        ...rest2,\n        uniqueId,\n        strand,\n        type: 'mRNA',\n        refName,\n        subfeatures,\n    };\n}\n","import { generateBedMethylFeature, isBedMethylFeature, } from './generateBedMethylFeature';\nimport { generateRepeatMaskerFeature, isRepeatMaskerDescriptionField, } from './generateRepeatMaskerFeature';\nimport { generateUcscTranscript, isUcscTranscript, } from './generateUcscTranscript';\nfunction defaultParser(fields, splitLine) {\n    let hasBlockCount = false;\n    const r = [];\n    for (let i = 0; i < splitLine.length; i++) {\n        if (fields[i] === 'blockCount') {\n            hasBlockCount = true;\n        }\n        r.push([fields[i], splitLine[i]]);\n    }\n    const obj = Object.fromEntries(r);\n    if (hasBlockCount) {\n        const { blockStarts, blockCount, chromStarts, thickEnd, thickStart, blockSizes, ...rest } = obj;\n        return {\n            ...rest,\n            blockStarts: arrayify(blockStarts),\n            chromStarts: arrayify(chromStarts),\n            blockSizes: arrayify(blockSizes),\n            thickStart: thickStart ? +thickStart : undefined,\n            thickEnd: thickEnd ? +thickEnd : undefined,\n            blockCount: blockCount ? +blockCount : undefined,\n        };\n    }\n    else {\n        return obj;\n    }\n}\nexport function makeBlocks({ start, uniqueId, refName, chromStarts, blockCount, blockSizes, blockStarts, }) {\n    const subfeatures = [];\n    const starts = chromStarts || blockStarts || [];\n    for (let b = 0; b < blockCount; b++) {\n        const bmin = (starts[b] || 0) + start;\n        const bsize = blockSizes === null || blockSizes === void 0 ? void 0 : blockSizes[b];\n        if (bsize && bsize > 0) {\n            const bmax = bmin + bsize;\n            subfeatures.push({\n                uniqueId: `${uniqueId}-${b}`,\n                start: bmin,\n                end: bmax,\n                refName,\n                type: 'block',\n            });\n        }\n    }\n    return subfeatures;\n}\nexport function featureData({ line, colRef, colStart, colEnd, scoreColumn, parser, uniqueId, names, }) {\n    const splitLine = line.split('\\t');\n    const refName = splitLine[colRef];\n    const start = Number.parseInt(splitLine[colStart], 10);\n    const end = Number.parseInt(splitLine[colEnd], 10) + (colStart === colEnd ? 1 : 0);\n    return featureData2({\n        splitLine,\n        refName,\n        start,\n        end,\n        parser,\n        uniqueId,\n        scoreColumn,\n        names,\n    });\n}\nexport function featureData2({ splitLine, refName, start, end, parser, uniqueId, scoreColumn, names, }) {\n    const data = names\n        ? defaultParser(names, splitLine)\n        : parser.parseLine(splitLine, { uniqueId });\n    const { strand: strand2, score: score2, chrom: _1, chromStart: _2, chromEnd: _3, ...rest } = data;\n    const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined;\n    const strand = typeof strand2 === 'string' ? (strand2 === '-' ? -1 : 1) : strand2;\n    const subfeatures = rest.blockCount\n        ? makeBlocks({\n            start,\n            uniqueId,\n            refName,\n            chromStarts: rest.chromStarts,\n            blockCount: rest.blockCount,\n            blockSizes: rest.blockSizes,\n            blockStarts: rest.blockStarts,\n        })\n        : undefined;\n    if (isBedMethylFeature({ splitLine, start, end })) {\n        return generateBedMethylFeature({\n            splitLine,\n            uniqueId,\n            refName,\n            start,\n            end,\n        });\n    }\n    else if (isRepeatMaskerDescriptionField(rest.description)) {\n        const { chromStarts, blockSizes, blockStarts, type, blockCount, thickStart, thickEnd, description, ...rest2 } = rest;\n        return generateRepeatMaskerFeature({\n            ...rest2,\n            uniqueId,\n            description,\n            type,\n            score,\n            start,\n            end,\n            strand,\n            refName,\n            subfeatures,\n        });\n    }\n    else if (subfeatures &&\n        isUcscTranscript({\n            strand,\n            blockCount: rest.blockCount,\n            thickStart: rest.thickStart,\n        })) {\n        const { chromStarts, blockSizes, type, blockCount, thickStart, thickEnd, description, } = rest;\n        return generateUcscTranscript({\n            ...rest,\n            description,\n            chromStarts,\n            thickStart,\n            thickEnd,\n            blockSizes,\n            blockCount,\n            type,\n            score,\n            start,\n            end,\n            strand,\n            refName,\n            uniqueId,\n            subfeatures,\n        });\n    }\n    else {\n        return {\n            ...rest,\n            uniqueId,\n            score,\n            start,\n            end,\n            strand,\n            refName,\n            subfeatures,\n        };\n    }\n}\nexport function arrayify(f) {\n    return f !== undefined\n        ? typeof f === 'string'\n            ? f.split(',').map(f => +f)\n            : f\n        : undefined;\n}\n"],"names":["peg$subclass","child","parent","ctor","peg$SyntaxError","message","expected","found","location","DESCRIBE_EXPECTATION_FNS","expectation","literalEscape","escapedParts","i","classEscape","hex","ch","s","describeExpectation","describeExpected","descriptions","j","describeFound","peg$parse","input","options","peg$FAILED","peg$startRuleFunctions","peg$parsedeclaration","peg$startRuleFunction","peg$c0","peg$c1","peg$literalExpectation","peg$c2","peg$c3","peg$c4","type","name","comment","fields","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","f1","w","peg$c20","fds","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","size","peg$c31","vals","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","t","n","peg$c64","peg$c65","peg$classExpectation","peg$c66","peg$c67","peg$c68","text","peg$c74","peg$c75","peg$c76","peg$c77","peg$otherExpectation","peg$c78","peg$c79","peg$c80","peg$c81","peg$c82","peg$c83","peg$currPos","peg$savedPos","peg$posDetailsCache","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","ignoreCase","parts","inverted","peg$endExpectation","description","peg$computePosDetails","pos","details","p","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s2","s3","s4","s5","s6","s7","s8","s9","s10","s11","s12","s13","peg$parse_","peg$parsedeclareType","peg$parsedeclareName","peg$parsecomment","peg$parsefieldList","peg$parsename","peg$parseindexType","peg$parsenonQuotedString","peg$parsefield","peg$parsecommentStart","peg$parseinternalComment","peg$parsefieldType","peg$parsefieldSize","peg$parsefieldValues","peg$parsenumber","parser","bigChain","bigGenePred","bigInteract","bigLink","bigMaf","bigNarrowPeak","bigPsl","defaultBedSchema","mafFrames","mafSummary","types","key","value","detectTypes","autoSql","numericTypes","autoField","f","strandMap","isBed12Like","_a","BED","arguments_","line","uniqueId","feature","index","columnValue","isNumeric","isArray","arrayIsNumeric","number_","fieldNames","isBedMethylFeature","splitLine","start","end","generateBedMethylFeature","refName","code","strand","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","isRepeatMaskerDescriptionField","desc","ret","makeRepeatTrackDescription","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","generateRepeatMaskerFeature","rest","isUcscTranscript","thickStart","blockCount","generateUcscTranscript","data","_1","_2","_3","chromStarts","blockStarts","blockSizes","oldSubfeatures","thickEnd","rest2","subfeatures","feats","a","b","block","defaultParser","hasBlockCount","r","obj","arrayify","makeBlocks","starts","bmin","bsize","bmax","featureData","colRef","colStart","colEnd","scoreColumn","names","featureData2","strand2","score2","score"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}