{"version":3,"file":"SNPCoverageAdapter-Bnkd7_8X.js","sources":["../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processDepth.js","../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/util.js","../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processMismatches.js","../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processModifications.js","../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processReferenceCpGs.js","../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/generateCoverageBins.js","../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/SNPCoverageAdapter.js"],"sourcesContent":["export function processDepth({ feature, bins, region, }) {\n    const fstart = feature.get('start');\n    const fend = feature.get('end');\n    const fstrand = feature.get('strand');\n    const regionLength = region.end - region.start;\n    for (let j = fstart; j < fend + 1; j++) {\n        const i = j - region.start;\n        if (i >= 0 && i < regionLength) {\n            if (bins[i] === undefined) {\n                bins[i] = {\n                    depth: 0,\n                    readsCounted: 0,\n                    ref: {\n                        probabilities: [],\n                        entryDepth: 0,\n                        '-1': 0,\n                        0: 0,\n                        1: 0,\n                    },\n                    snps: {},\n                    mods: {},\n                    nonmods: {},\n                    delskips: {},\n                    noncov: {},\n                };\n            }\n            if (j !== fend) {\n                bins[i].depth++;\n                bins[i].readsCounted++;\n                bins[i].ref.entryDepth++;\n                bins[i].ref[fstrand]++;\n            }\n        }\n    }\n}\n","export function mismatchLen(mismatch) {\n    return !isInterbase(mismatch.type) ? mismatch.length : 1;\n}\nexport function isInterbase(type) {\n    return type === 'softclip' || type === 'hardclip' || type === 'insertion';\n}\nexport function inc(bin, strand, type, field) {\n    let thisBin = bin[type][field];\n    if (thisBin === undefined) {\n        thisBin = bin[type][field] = {\n            entryDepth: 0,\n            probabilities: [],\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n        };\n    }\n    thisBin.entryDepth++;\n    thisBin[strand]++;\n}\nexport function incWithProbabilities(bin, strand, type, field, probability) {\n    let thisBin = bin[type][field];\n    if (thisBin === undefined) {\n        thisBin = bin[type][field] = {\n            entryDepth: 0,\n            probabilities: [],\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n        };\n    }\n    thisBin.entryDepth++;\n    thisBin.probabilities.push(probability);\n    thisBin[strand]++;\n}\n","import { inc, isInterbase, mismatchLen } from './util';\nexport function processMismatches({ feature, region, bins, skipmap, }) {\n    var _a;\n    const fstart = feature.get('start');\n    const fstrand = feature.get('strand');\n    const mismatches = (_a = feature.get('mismatches')) !== null && _a !== void 0 ? _a : [];\n    for (const mismatch of mismatches) {\n        const mstart = fstart + mismatch.start;\n        const mlen = mismatchLen(mismatch);\n        const mend = mstart + mlen;\n        for (let j = mstart; j < mstart + mlen; j++) {\n            const epos = j - region.start;\n            if (epos >= 0 && epos < bins.length) {\n                const bin = bins[epos];\n                const { base, altbase, type } = mismatch;\n                const interbase = isInterbase(type);\n                if (type === 'deletion' || type === 'skip') {\n                    inc(bin, fstrand, 'delskips', type);\n                    bin.depth--;\n                }\n                else if (!interbase) {\n                    inc(bin, fstrand, 'snps', base);\n                    bin.ref.entryDepth--;\n                    bin.ref[fstrand]--;\n                    bin.refbase = altbase;\n                }\n                else {\n                    inc(bin, fstrand, 'noncov', type);\n                }\n            }\n        }\n        if (mismatch.type === 'skip') {\n            const tags = feature.get('tags');\n            const xs = (tags === null || tags === void 0 ? void 0 : tags.XS) || (tags === null || tags === void 0 ? void 0 : tags.TS);\n            const ts = tags === null || tags === void 0 ? void 0 : tags.ts;\n            const effectiveStrand = xs === '+'\n                ? 1\n                : xs === '-'\n                    ? -1\n                    : (ts === '+' ? 1 : xs === '-' ? -1 : 0) * fstrand;\n            const hash = `${mstart}_${mend}_${effectiveStrand}`;\n            if (skipmap[hash] === undefined) {\n                skipmap[hash] = {\n                    feature: feature,\n                    start: mstart,\n                    end: mend,\n                    strand: fstrand,\n                    effectiveStrand,\n                    score: 0,\n                };\n            }\n            skipmap[hash].score++;\n        }\n    }\n}\n","import { max, sum } from '@jbrowse/core/util';\nimport { incWithProbabilities } from './util';\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition';\nexport function processModifications({ feature, colorBy, region, bins, regionSequence, }) {\n    var _a, _b, _c;\n    const fstart = feature.get('start');\n    const fstrand = feature.get('strand');\n    const fend = feature.get('end');\n    const twoColor = (_a = colorBy === null || colorBy === void 0 ? void 0 : colorBy.modifications) === null || _a === void 0 ? void 0 : _a.twoColor;\n    const isolatedModification = (_b = colorBy === null || colorBy === void 0 ? void 0 : colorBy.modifications) === null || _b === void 0 ? void 0 : _b.isolatedModification;\n    (_c = getMaxProbModAtEachPosition(feature)) === null || _c === void 0 ? void 0 : _c.forEach(({ type, prob, allProbs }, pos) => {\n        if (isolatedModification && type !== isolatedModification) {\n            return;\n        }\n        const epos = pos + fstart - region.start;\n        if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n            if (bins[epos] === undefined) {\n                bins[epos] = {\n                    depth: 0,\n                    readsCounted: 0,\n                    refbase: regionSequence[epos],\n                    snps: {},\n                    ref: {\n                        probabilities: [],\n                        entryDepth: 0,\n                        '-1': 0,\n                        0: 0,\n                        1: 0,\n                    },\n                    mods: {},\n                    nonmods: {},\n                    delskips: {},\n                    noncov: {},\n                };\n            }\n            const s = 1 - sum(allProbs);\n            const bin = bins[epos];\n            if (twoColor && s > max(allProbs)) {\n                incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s);\n            }\n            else {\n                incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob);\n            }\n        }\n    });\n}\n","import { doesIntersect2 } from '@jbrowse/core/util';\nimport { parseCigar } from '../MismatchParser';\nimport { getMethBins } from '../ModificationParser';\nimport { incWithProbabilities } from './util';\nexport function processReferenceCpGs({ feature, region, bins, regionSequence, }) {\n    var _a;\n    const fstart = feature.get('start');\n    const fend = feature.get('end');\n    const fstrand = feature.get('strand');\n    const seq = feature.get('seq');\n    const mismatches = (_a = feature.get('mismatches')) !== null && _a !== void 0 ? _a : [];\n    const r = regionSequence.toLowerCase();\n    if (seq) {\n        const cigarOps = parseCigar(feature.get('CIGAR'));\n        const { methBins, methProbs } = getMethBins(feature, cigarOps);\n        const dels = mismatches.filter(f => f.type === 'deletion');\n        for (let i = 0; i < fend - fstart; i++) {\n            const j = i + fstart;\n            const l1 = r[j - region.start + 1];\n            const l2 = r[j - region.start + 2];\n            if (l1 === 'c' && l2 === 'g') {\n                const bin0 = bins[j - region.start];\n                const bin1 = bins[j - region.start + 1];\n                const b0 = methBins[i];\n                const b1 = methBins[i + 1];\n                const p0 = methProbs[i];\n                const p1 = methProbs[i + 1];\n                if ((b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n                    (b1 && (p1 !== undefined ? p1 > 0.5 : true))) {\n                    if (bin0) {\n                        incWithProbabilities(bin0, fstrand, 'mods', 'cpg_meth', p0 || 0);\n                        bin0.ref.entryDepth--;\n                        bin0.ref[fstrand]--;\n                    }\n                    if (bin1) {\n                        incWithProbabilities(bin1, fstrand, 'mods', 'cpg_meth', p1 || 0);\n                        bin1.ref.entryDepth--;\n                        bin1.ref[fstrand]--;\n                    }\n                }\n                else {\n                    if (bin0) {\n                        if (!dels.some(d => doesIntersect2(j, j + 1, d.start + fstart, d.start + fstart + d.length))) {\n                            incWithProbabilities(bin0, fstrand, 'nonmods', 'cpg_unmeth', 1 - (p0 || 0));\n                            bin0.ref.entryDepth--;\n                            bin0.ref[fstrand]--;\n                        }\n                    }\n                    if (bin1) {\n                        if (!dels.some(d => doesIntersect2(j + 1, j + 2, d.start + fstart, d.start + fstart + d.length))) {\n                            incWithProbabilities(bin1, fstrand, 'nonmods', 'cpg_unmeth', 1 - (p1 || 0));\n                            bin1.ref.entryDepth--;\n                            bin1.ref[fstrand]--;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","import { sum } from '@jbrowse/core/util';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { processDepth } from './processDepth';\nimport { processMismatches } from './processMismatches';\nimport { processModifications } from './processModifications';\nimport { processReferenceCpGs } from './processReferenceCpGs';\nexport async function generateCoverageBins({ fetchSequence, features, region, opts, }) {\n    const { stopToken, colorBy } = opts;\n    const skipmap = {};\n    const bins = [];\n    const start2 = Math.max(0, region.start - 1);\n    const diff = region.start - start2;\n    let start = performance.now();\n    for (const feature of features) {\n        if (performance.now() - start > 400) {\n            checkStopToken(stopToken);\n            start = performance.now();\n        }\n        processDepth({\n            feature,\n            bins,\n            region,\n        });\n        if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {\n            const regionSequence = (await fetchSequence({\n                ...region,\n                start: start2,\n                end: region.end + 1,\n            })) || '';\n            processModifications({\n                feature,\n                colorBy,\n                bins,\n                region,\n                regionSequence: regionSequence.slice(diff),\n            });\n        }\n        else if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'methylation') {\n            const regionSequence = (await fetchSequence({\n                ...region,\n                start: start2,\n                end: region.end + 1,\n            })) || '';\n            processReferenceCpGs({\n                feature,\n                bins,\n                region,\n                regionSequence,\n            });\n        }\n        processMismatches({ feature, skipmap, bins, region });\n    }\n    for (const bin of bins) {\n        if (bin) {\n            bin.mods = Object.fromEntries(Object.entries(bin.mods).map(([key, val]) => {\n                return [\n                    key,\n                    {\n                        ...val,\n                        avgProbability: val.probabilities.length\n                            ? sum(val.probabilities) / val.probabilities.length\n                            : undefined,\n                    },\n                ];\n            }));\n            bin.nonmods = Object.fromEntries(Object.entries(bin.nonmods).map(([key, val]) => {\n                return [\n                    key,\n                    {\n                        ...val,\n                        avgProbability: val.probabilities.length\n                            ? sum(val.probabilities) / val.probabilities.length\n                            : undefined,\n                    },\n                ];\n            }));\n        }\n    }\n    return {\n        bins,\n        skipmap,\n    };\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { firstValueFrom } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\nimport { fetchSequence } from '../util';\nimport { generateCoverageBins } from './generateCoverageBins';\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n    async configure() {\n        var _a, _b;\n        const subadapterConfig = this.getConf('subadapter');\n        const sequenceConf = subadapterConfig.sequenceAdapter;\n        const dataAdapter = await ((_a = this.getSubAdapter) === null || _a === void 0 ? void 0 : _a.call(this, subadapterConfig));\n        const sequenceAdapter = sequenceConf\n            ? await ((_b = this.getSubAdapter) === null || _b === void 0 ? void 0 : _b.call(this, sequenceConf))\n            : undefined;\n        if (!dataAdapter) {\n            throw new Error('Failed to get subadapter');\n        }\n        return {\n            subadapter: dataAdapter.dataAdapter,\n            sequenceAdapter: sequenceAdapter === null || sequenceAdapter === void 0 ? void 0 : sequenceAdapter.dataAdapter,\n        };\n    }\n    async fetchSequence(region) {\n        const { sequenceAdapter } = await this.configure();\n        if (!sequenceAdapter) {\n            return undefined;\n        }\n        return fetchSequence(region, sequenceAdapter);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { subadapter } = await this.configure();\n            const features = await firstValueFrom(subadapter.getFeatures(region, opts).pipe(toArray()));\n            const { bins, skipmap } = await generateCoverageBins({\n                features,\n                region,\n                opts,\n                fetchSequence: (region) => this.fetchSequence(region),\n            });\n            bins.forEach((bin, index) => {\n                const start = region.start + index;\n                observer.next(new SimpleFeature({\n                    id: `${this.id}-${start}`,\n                    data: {\n                        score: bin.depth,\n                        snpinfo: bin,\n                        start,\n                        end: start + 1,\n                        refName: region.refName,\n                    },\n                }));\n            });\n            Object.entries(skipmap).forEach(([key, skip]) => {\n                observer.next(new SimpleFeature({\n                    id: key,\n                    data: {\n                        type: 'skip',\n                        start: skip.start,\n                        end: skip.end,\n                        strand: skip.strand,\n                        score: skip.score,\n                        effectiveStrand: skip.effectiveStrand,\n                    },\n                }));\n            });\n            observer.complete();\n        }, opts.stopToken);\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        const { subadapter } = await this.configure();\n        return subadapter.getMultiRegionFeatureDensityStats(regions, opts);\n    }\n    async getRefNames(opts = {}) {\n        const { subadapter } = await this.configure();\n        return subadapter.getRefNames(opts);\n    }\n    freeResources() { }\n}\n"],"names":["processDepth","feature","bins","region","fstart","fend","fstrand","regionLength","j","mismatchLen","mismatch","isInterbase","type","inc","bin","strand","field","thisBin","incWithProbabilities","probability","processMismatches","skipmap","_a","mismatches","mstart","mlen","mend","epos","base","altbase","interbase","tags","xs","ts","effectiveStrand","hash","processModifications","colorBy","regionSequence","_b","_c","twoColor","isolatedModification","getMaxProbModAtEachPosition","prob","allProbs","pos","s","sum","max","processReferenceCpGs","seq","r","cigarOps","parseCigar","methBins","methProbs","getMethBins","dels","f","i","l1","l2","bin0","bin1","b0","b1","p0","p1","d","doesIntersect2","generateCoverageBins","fetchSequence","features","opts","stopToken","start2","diff","start","checkStopToken","key","val","SNPCoverageAdapter","BaseFeatureDataAdapter","subadapterConfig","sequenceConf","dataAdapter","sequenceAdapter","ObservableCreate","observer","subadapter","firstValueFrom","toArray","index","SimpleFeature","skip","regions"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}