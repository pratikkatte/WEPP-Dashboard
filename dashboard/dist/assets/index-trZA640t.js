import{aU as L}from"./index-BF7YmVSy.js";function C(r,e,t){const n=e.split("	"),i={};let o=0;if(r.includes("GT")){const a=r.split(":");if(a.length===1)for(const s of t)i[s]=n[o++];else{const s=a.indexOf("GT");if(s===0)for(const l of t){const c=n[o++],p=c.indexOf(":");i[l]=p!==-1?c.slice(0,p):c}else for(const l of t){const c=n[o++].split(":");i[l]=c[s]}}}return i}function w(r){const e=[];let t="",n=!1,i=!1;for(const o of r)o==='"'?(n=!n,t+=o):o==="["?(i=!0,t+=o):o==="]"?(i=!1,t+=o):o===","&&!n&&!i?(e.push(t.trim()),t=""):t+=o;return t&&e.push(t.trim()),e}function V(r,e){const t=r.indexOf(e);return[r.slice(0,t),r.slice(t+1)]}function G(r){const e=r.replace(/^<|>$/g,"");return Object.fromEntries(w(e).map(t=>{const[n,i]=V(t,"=");return i&&i.startsWith("[")&&i.endsWith("]")?[n,i.slice(1,-1).split(",").map(o=>o.trim())]:i&&i.startsWith('"')&&i.endsWith('"')?[n,i.slice(1,-1)]:[n,i==null?void 0:i.replaceAll(/^"|"$/g,"")]}))}const N={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function k(r){try{return decodeURIComponent(r)}catch{return r}}class Q{constructor({header:e="",strict:t=!0}){if(!e.length)throw new Error("empty header received");const n=e.split(/[\r\n]+/).filter(Boolean);if(!n.length)throw new Error("no non-empty header lines specified");this.strict=t,this.metadata=JSON.parse(JSON.stringify({INFO:N.InfoFields,FORMAT:N.GenotypeFields,ALT:N.AltTypes,FILTER:N.FilterTypes}));let i;if(n.forEach(l=>{if(l.startsWith("#"))l.startsWith("##")?this.parseMetadata(l):i=l;else throw new Error(`Bad line in header:
${l}`)}),!i)throw new Error("No format line found in header");const o=i.trim().split("	"),a=o.slice(0,8),s=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(o.length<8)throw new Error(`VCF header missing columns:
${i}`);if(a.length!==s.length||!a.every((l,c)=>l===s[c]))throw new Error(`VCF column headers not correct:
${i}`);this.samples=o.slice(9)}parseSamples(e,t){const n={};if(e){const i=t.split("	"),o=e.split(":"),a=o.map(s=>{const l=this.getMetadata("FORMAT",s,"Type");return l==="Integer"||l==="Float"});for(let s=0;s<this.samples.length;s++){const l=this.samples[s];n[l]={};const c=i[s].split(":");for(let p=0;p<c.length;p++){const d=c[p];n[l][o[p]]=d===""||d==="."?void 0:d.split(",").map(f=>f==="."?void 0:a[p]?+f:f)}}}return n}parseMetadata(e){const t=/^##(.+?)=(.*)/.exec(e.trim());if(!t)throw new Error(`Line is not a valid metadata line: ${e}`);const[n,i]=t.slice(1,3),o=n;if(i!=null&&i.startsWith("<")){o in this.metadata||(this.metadata[o]={});const[a,s]=this.parseStructuredMetaVal(i);a?this.metadata[o][a]=s:this.metadata[o]=s}else this.metadata[o]=i}parseStructuredMetaVal(e){const t=G(e),n=t.ID;return delete t.ID,"Number"in t&&(Number.isNaN(Number(t.Number))||(t.Number=Number(t.Number))),[n,t]}getMetadata(...e){let t=this.metadata;for(const n of e)if(t=t[n],!t)return t;return t}parseLine(e){var I;let t=0;for(let D=0;t<e.length&&(e[t]==="	"&&(D+=1),D!==9);t+=1);const n=e.slice(0,t).split("	"),i=e.slice(t+1),[o,a,s,l,c,p,d]=n,f=o,A=+a,E=s==="."?void 0:s.split(";"),R=l,v=c==="."?void 0:c.split(","),F=p==="."?void 0:+p,h=d==="."?void 0:d.split(";"),O=n[8];if(this.strict&&!n[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const P=(I=n[7])==null?void 0:I.includes("%"),M=n[7]===void 0||n[7]==="."?{}:Object.fromEntries(n[7].split(";").map(D=>{const[g,b]=D.split("="),y=b==null?void 0:b.split(",").map(u=>u==="."?void 0:u).map(u=>u&&P?k(u):u),T=this.getMetadata("INFO",g,"Type");return T==="Integer"||T==="Float"?[g,y==null?void 0:y.map(u=>u===void 0?void 0:Number(u))]:T==="Flag"?[g,!0]:[g,y??!0]}));return{CHROM:f,POS:A,ALT:v,INFO:M,REF:R,FILTER:h&&h.length===1&&h[0]==="PASS"?"PASS":h,ID:E,QUAL:F,FORMAT:O,SAMPLES:()=>this.parseSamples(n[8]??"",i),GENOTYPES:()=>C(n[8]??"",i,this.samples)}}}const q={DEL:"deletion",INS:"insertion",DUP:"duplication",INV:"inversion",INVDUP:"inverted_duplication",CNV:"copy_number_variation",TRA:"translocation","DUP:TANDEM":"tandem_duplication",NON_REF:"sequence_variant","*":"sequence_variant"};function H(r,e,t){if(!e||e.length===0)return["remark","no alternative alleles"];const n=new Set;let i=new Set;if(e.forEach(o=>{let[a,s]=S(o,t);a||([a,s]=U(r,o)),a&&s&&(n.add(a),i.add(s))}),i.size>1){const o=[...i],a=new Set(o.map(s=>{const l=s.split("->");return l[1]?l[0]:s}).filter(s=>!!s));i=new Set([...a].map(s=>s.trim()).map(s=>{const l=o.map(c=>c.split("->").map(p=>p.trim())).map(c=>c[1]&&c[0]===s?c[1]:"").filter(c=>!!c);return l.length?`${s} -> ${l.join(",")}`:s}))}return n.size?[[...n].join(","),[...i].join(",")]:[]}function S(r,e){if(typeof r=="string"&&!r.startsWith("<"))return[];let t=q[r];if(!t&&e.getMetadata("ALT",r)&&(t="sequence_variant"),t)return[t,r];const n=r.split(":");return n.length>1?S(`<${n.slice(0,-1).join(":")}>`,e):[]}function U(r,e){if(L(e))return["breakend",e];if(r.length===1&&e.length===1)return["SNV",m("SNV",r,e)];if(e==="<INS>")return["insertion",e];if(e==="<DEL>")return["deletion",e];if(e==="<DUP>")return["duplication",e];if(e==="<CNV>")return["cnv",e];if(e==="<INV>")return["inversion",e];if(e==="<TRA>")return["translocation",e];if(e.includes("<"))return["sv",e];if(r.length===e.length)return r.split("").reverse().join("")===e?["inversion",m("inversion",r,e)]:["substitution",m("substitution",r,e)];if(r.length<=e.length){const n=e.length-r.length,i=n.toLocaleString("en-US");return["insertion",n>5?`${i}bp INS`:m("insertion",r,e)]}if(r.length>e.length){const n=r.length-e.length,i=n.toLocaleString("en-US");return["deletion",n>5?`${i}bp DEL`:m("deletion",r,e)]}return["indel",m("indel",r,e)]}function m(r,e,t){return`${r} ${e} -> ${t}`}function _(r,e){const{REF:t="",ALT:n,POS:i,CHROM:o,ID:a}=r,s=i-1,[l,c]=H(t,n,e);return{refName:o,start:s,end:$(r),description:c,type:l,name:a==null?void 0:a.join(","),aliases:a&&a.length>1?a.slice(1):void 0}}function $(r){const{POS:e,REF:t="",ALT:n}=r,i=n==null?void 0:n.includes("<TRA>"),o=e-1;if(n==null?void 0:n.some(s=>s.includes("<"))){const s=r.INFO;if(s.END&&!i)return+s.END[0]}return o+t.length}class j{constructor(e){this.variant=e.variant,this.parser=e.parser,this.data=_(this.variant,this.parser),this._id=e.id}get(e){var t;return e==="samples"?this.variant.SAMPLES():e==="genotypes"?this.variant.GENOTYPES():(t=this.data[e])!==null&&t!==void 0?t:this.variant[e]}parent(){}children(){}id(){return this._id}toJSON(){const{SAMPLES:e,GENOTYPES:t,...n}=this.variant;return{uniqueId:this._id,...n,...this.data,samples:this.variant.SAMPLES()}}}export{Q as V,j as a};
//# sourceMappingURL=index-trZA640t.js.map
